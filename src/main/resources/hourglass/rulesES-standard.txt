# DATES ENGLISH
# Example to add "DATEPRP" as ner tag, and ISO code as the normalized tag for strings matching a color

# Case insensitive pattern matching (see java.util.regex.Pattern flags)

# Map variable names to annotation keys
 myNER = { type: "CLASS", value: "oeg.tagger.core.time.annotation.myNER$MyNamedEntityTagAnnotation" }
 myNUM = { type: "CLASS", value: "oeg.tagger.core.time.annotation.myNER$MyNumTagAnnotation" }
 myNERnormalized = { type: "CLASS", value: "oeg.tagger.core.time.annotation.myNER$MyNormalizedNamedEntityTagAnnotation" }
 myT = { type: "CLASS", value: "oeg.tagger.core.time.annotation.myNER$MyNamedEntityTagAnnotation" }
# myTnormalized = { type: "CLASS", value: "oeg.tagger.core.time.annotation.myNER$MyNormalizedNamedEntityTagAnnotation" }
 myTType = { type: "CLASS", value: "oeg.tagger.core.time.annotation.temporal$MyTypeTemporalAnnotation" }
 
myTValue = { type: "CLASS", value: "oeg.tagger.core.time.annotation.temporal$MyValueAnnotation" }

mySTValue = { type: "CLASS", value: "oeg.tagger.core.time.annotation.temporal$MyStringValueAnnotation" }

myRule = { type: "CLASS", value: "oeg.tagger.core.time.annotation.temporal$MyRuleAnnotation" }

 timexType = { type: "CLASS", value: "oeg.tagger.core.time.annotation.timex$Type" }
 timexValue = { type: "CLASS", value: "oeg.tagger.core.time.annotation.timex$Value" }
 timexFreq = { type: "CLASS", value: "oeg.tagger.core.time.annotation.timex$Freq" }
 timexQuant = { type: "CLASS", value: "oeg.tagger.core.time.annotation.timex$Quant" }
 



ner = { type: "CLASS", value: "edu.stanford.nlp.ling.CoreAnnotations$NamedEntityTagAnnotation" }
normalized = { type: "CLASS", value: "edu.stanford.nlp.ling.CoreAnnotations$NormalizedNamedEntityTagAnnotation" }
tokens = { type: "CLASS", value: "edu.stanford.nlp.ling.CoreAnnotations$TokensAnnotation" }

# TIME

myTimeHour = { type: "CLASS", value: "oeg.tagger.core.time.annotation.time$MyHour" }

myTimeMinute = { type: "CLASS", value: "oeg.tagger.core.time.annotation.time$MyMinute" }

myTimeSecond = { type: "CLASS", value: "oeg.tagger.core.time.annotation.time$MySecond" }

myTimePartDay = { type: "CLASS", value: "oeg.tagger.core.time.annotation.time$MyPartDay" }	  

# DATE

myDateDay = { type: "CLASS", value: "oeg.tagger.core.time.annotation.date$MyDay" }

myDateMonth = { type: "CLASS", value: "oeg.tagger.core.time.annotation.date$MyMonth" }

myDateYear = { type: "CLASS", value: "oeg.tagger.core.time.annotation.date$MyYear" }

myDateDayWeek = { type: "CLASS", value: "oeg.tagger.core.time.annotation.date$MyDayWeek" }

myDateWeek = { type: "CLASS", value: "oeg.tagger.core.time.annotation.date$MyWeek" }


# Duration

myDurationWeek = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MyWeeks" }

myDurationHour = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MyHours" }

myDurationDay = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MyDays" }

myDurationMinute = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MyMinutes" }

myDurationSecond = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MySeconds" }

myDurationMonth = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MyMonths" }

myDurationYear = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MyYears" }

myDurationDecade = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MyDecades" }

myDurationDayWeek = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MyDayWeeks" }

myDurationWeekend = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$MyWeekends" }

Period = { type: "CLASS", value: "oeg.tagger.core.time.annotation.duration$Period" }




mytokens = { type: "CLASS", value: "oeg.tagger.core.time.annotation.temporal$MyTokensAnnotation" } 	 	

#ENV.defaultResultAnnotationKey = ( type, value ) 
ENV.defaultNestedResultsAnnotationKey = mytokens 
#ENV.defaults["stage.limitIters"] = 0

ENV.defaultResultAnnotationKey = (timexType, timexValue, timexFreq, timexQuant, myRule)
ENV.defaults["stage"] = 1

# Create OR pattern of
#  regular expression over temporal expressions
$MONTHS = (
  [{lemma:/[E|e]nero/} & !{ pos:/NP.*/ }]     => 01 |
  [{lemma:/[F|f]ebrero/} & !{ pos:/NP.*/ }]   => 02 |
  [{lemma:/[M|m]arzo/} & !{ pos:/NP.*/ }]    => 03 |
  [{lemma:/[A|a]bril/} ]   => 04 | #TODO: Check this...
  [{lemma:/[M|m]ayo/} & !{ pos:/NP.*/ }]   => 05 |
  [{lemma:/[J|j]unio/} & !{ pos:/NP.*/ }]    => 06 |
  [{lemma:/[J|j]ulio/} & !{ pos:/NP.*/ }]    => 07 | #TODO: Check this...
  [{lemma:/[A|a]gosto/} & !{ pos:/NP.*/ }]    => 08 |
  [{lemma:/[S|s]eptiembre/} & !{ pos:/NP.*/ }]    => 09 |
  [{lemma:/[O|o]ctubre/} & !{ pos:/NP.*/ }]    => 10 |
  [{lemma:/[N|n]oviembre/} & !{ pos:/NP.*/ }]    => 11 |
  [{lemma:/[D|d]iciembre/} & !{ pos:/NP.*/ }]    => 12
)

$WEEKL = (
  [{lemma:/[L|l]unes/} & !{ pos:/NP.*/ }]     => 01 |
  [{lemma:/[M|m]artes/} & !{ pos:/NP.*/ }]   => 02 |
  [{lemma:/[M|m]iércoles/} & !{ pos:/NP.*/ }]    => 03 |
  [{lemma:/[J|j]ueves/} & !{ pos:/NP.*/ }]     => 04 |
  [{lemma:/[V|v]iernes/} & !{ pos:/NP.*/ }]   => 05 |
  [{lemma:/[S|s]ábado/} & !{ pos:/NP.*/ }]    => 06 |
  [{lemma:/[D|d]omingo/}  & !{ pos:/NP.*/ }]    => 07
) 

$SEASON = (
  [{lemma:/otoño/}]     => "FA" |
  [{lemma:/invierno/}]   => "WI" |
  [{lemma:/primavera/}]    => "SP" |
  [{lemma:/verano/}]     => "SU" 
)


$DAYMONTHN = (
  /01|1/ => 01 |
  /02|2/   => 02 |
  /03|3/    => 03 |
  /04|4/     => 04 |
  /05|5/   => 05 |
  /06|6/    => 06 |  
  /07|7/    => 07 |
  /08|8/     => 08 |
  /09|9/   => 09 |
  /10/   => 10 |
  /11/   => 11 |
  /12/   => 12 |
  /13/   => 13 |
  /14/   => 14 |
  /15/   => 15 |
  /16/   => 16 |
  /17/   => 17 |
  /18/   => 18 |
  /19/   => 19 |
  /20/   => 20 |
  /21/   => 21 |
  /22/   => 22 |
  /23/   => 23 |
  /24/   => 24 |
  /25/   => 25 |
  /26/   => 26 |
  /27/   => 27 |
  /28/   => 28 |
  /29/   => 29 |
  /30/   => 30 |
  /31/   => 31
)

$MONTHN = (
  /01|1/ => 01 |
  /02|2/   => 02 |
  /03|3/    => 03 |
  /04|4/     => 04 |
  /05|5/   => 05 |
  /06|6/    => 06 |  
  /07|7/    => 07 |
  /08|8/     => 08 |
  /09|9/   => 09 |
  /10/   => 10 |
  /11/   => 11 |
  /12/   => 12
)

$ORDINALS = (
  [{word:/primer|primera|primero/}] => 01 |
  [{word:/segundo|segunda/}]   => 02 |
  [{word:/tercer|tercera/}]    => 03 |
  [{word:/cuarto|cuarta/}]     => 04 |
  [{word:/quinto|quinta/}]   => 05 |
  [{word:/sexto|sexta/}]    => 06 |  
  [{word:/séptimo|séptima/}]    => 07 |
  [{word:/octavo|octava/}]     => 08 |
  [{word:/noveno|novena/}]   => 09 |
  [{word:/décima|décimo/}]   => 10 |
  [{word:/decimoprimer|decimoprimera/}]   => 11 |
  [{word:/decimosegundo|decimosegunda/}]   => 12 |
  [{word:/decimotercer|decimotercera/}]   => 13 |
  [{word:/decimocuarto|decimocuarta/}]   => 14 |
  [{word:/decimoquinto|decimoquinta/}]   => 15 |
  [{word:/decimosexto|decimosexta/}]    => 16 |  
  [{word:/decimoséptimo|decimoséptima/}]    => 17 |
  [{word:/decimooctavo|decimooctava/}]     => 18 |
  [{word:/decimonoveno|decimonovena/}]   => 19 |
  [{word:/vigésimo|vigésima/}]   => 20 |
  [{word:/vigesimoprimer|vigesimoprimera/}] => 21 |
  [{word:/vigesimosegundo|vigesimosegunda/}]   => 22 |
  [{word:/vigesimotercer|vigesimotercera/}]    => 23 |
  [{word:/vigesimocuarto|vigesimocuarta/}]     => 24 |
  [{word:/vigesimoquinto|vigesimoquinta/}]   => 25 |
  [{word:/vigesimosexto|vigesimosexta/}]    => 26 |  
  [{word:/vigesimoséptimo|vigesimoséptima/}]    => 27 |
  [{word:/vigesimoctavo|vigesimoctava/}]     => 28 |
  [{word:/vigesimonoveno|vigesimonovena/}]   => 29 |
  [{word:/trigésimo|trigésima/}]   => 30 |
  [{word:/trigesimoprimer|trigesimoprimera/}]   => 31
)

DGRANULARITY_MAP = {
  "día" : "DAY",
  "días" : "DAY",
  "jornada" : "DAY",
  "jornadas" : "DAY",
  "finsemana"   : "WEEKEND",
  "semana"    : "WEEK",
  "semanas"    : "WEEK",
  "quincena"     : "FORNIGHT",
  "quincenas"     : "FORNIGHT",
  "mes"   : "MONTH",
  "meses"   : "MONTH",
  "bimestre"    : "2_MONTH",  
  "bimestres"    : "2_MONTH",  
  "trimestre"    : "3_MONTH",
  "trimestres"    : "3_MONTH",
  "cuatrimestre"     : "4_MONTH",
  "cuatrimestres"     : "4_MONTH",
  "semestre"   : "6_MONTH",
  "semestres"   : "6_MONTH",
  "año"   : "YEAR",
  "años"   : "YEAR",
  "bienio"    : "2_YEAR",
  "bienios"    : "2_YEAR",
  "trienio"    : "3_YEAR",
  "trienios"    : "3_YEAR",
  "lustro"   : "5_YEAR",
  "lustros"   : "5_YEAR",
  "decada"   : "10_YEAR",
  "decadas"   : "10_YEAR",
  "década"   : "10_YEAR",
  "décadas"   : "10_YEAR",
  "decenio"   : "10_YEAR",
  "decenios"   : "10_YEAR",
  "siglo"   : "100_YEAR",
  "siglos"   : "100_YEAR",
  "milenio"   : "1000_YEAR",
  "milenios"   : "1000_YEAR"
}
$DGranularity = CreateRegex(Keys(DGRANULARITY_MAP))



DURATION_MAP = {
  "DAY" : "myDurationDay" ,
  "WEEKEND"   : "myDurationWeekend" ,
  "WEEK"    : "myDurationWeek" ,
  "FORNIGHT"     : "myDurationWeek" ,
  "MONTH"   : "myDurationMonth" ,
  "2_MONTH"    : "myDurationMonth" ,  
  "3_MONTH"    : "myDurationMonth" ,
  "4_MONTH"     : "myDurationMonth" ,
  "6_MONTH"   : "myDurationMonth" ,
  "YEAR"   : "myDurationYear" ,
  "2_YEAR"   : "myDurationYear" ,
  "3_YEAR"   : "myDurationYear" ,
  "5_YEAR"   : "myDurationYear" ,
  "10_YEAR"   : "myDurationYear" ,
  "100_YEAR"   : "myDurationDecade" ,
  "1000_YEAR"   : "myDurationYear",
  "HOUR"	: "myDurationHour",
  "MINUTE"	: "myDurationMinute",
  "SECOND"	: "myDurationSecond"
}

HALF_DURATION_MAP = {
  "DAY" : "0.5D" ,
  "WEEKEND"   : "0.5WE" ,
  "WEEK"    : "0.5W" ,
  "FORNIGHT"     : "1W" ,
  "MONTH"   : "0.5M" ,
  "2_MONTH"	: "1M",
  "3_MONTH"	: "0.5Q",
  "4_MONTH"	: "0.5T",
  "6_MONTH"	: "0.5HALF",
  "YEAR"   : "0.5Y" ,
  "2_YEAR"   : "1Y" ,
  "3_YEAR"   : "1.5Y" ,
  "5_YEAR"   : "2.5Y" ,
  "10_YEAR"   : "5Y" ,
  "100_YEAR"   : "50Y" ,
  "1000_YEAR"   : "500Y",
  "HOUR"	: "0.5H",
  "MINUTE"	: "0.5MIN",
  "SECOND"	: "0.5S"
}

QUARTER_DURATION_MAP = {
  "DAY" : "0.25D" ,
  "WEEKEND"   : "0.25WE" ,
  "WEEK"    : "0.25W" ,
  "FORNIGHT"     : "0.5W" ,
  "MONTH"   : "0.25M" ,
  "2_MONTH"	: "0.5M",
  "3_MONTH"	: "0.25Q",
  "4_MONTH"	: "0.25T",
  "6_MONTH"	: "0.25HALF",
  "YEAR"   : "0.25Y" ,
  "2_YEAR"   : "0.5Y" ,
  "3_YEAR"   : "0.75Y" ,
  "5_YEAR"   : "1.5Y" ,
  "10_YEAR"   : "2.5Y" ,
  "100_YEAR"   : "25Y" ,
  "1000_YEAR"   : "250Y",
  "HOUR"	: "0.25H",
  "MINUTE"	: "0.25MIN",
  "SECOND"	: "0.25S"
}

TQUARTER_DURATION_MAP = {
  "DAY" : "0.75D" ,
  "WEEKEND"   : "0.75WE" ,
  "WEEK"    : "0.75W" ,
  "FORNIGHT"     : "1.5W" ,
  "MONTH"   : "0.75M" ,
  "2_MONTH"	: "1.5M",
  "3_MONTH"	: "0.75Q",
  "4_MONTH"	: "0.75T",
  "6_MONTH"	: "0.75HALF",
  "YEAR"   : "0.75Y" ,
  "2_YEAR"   : "1.5Y" ,
  "3_YEAR"   : "2.25Y" ,
  "5_YEAR"   : "3.75Y" ,
  "10_YEAR"   : "7.5Y" ,
  "100_YEAR"   : "75Y" ,
  "1000_YEAR"   : "750Y",
  "HOUR"	: "0.75H",
  "MINUTE"	: "0.75MIN",
  "SECOND"	: "0.75S"
}

#TQUARTER_DURATION_MAP = {
#  "DAY" : "18H" ,
#  "WEEKEND"   : "1D12H" ,
#  "WEEK"    : "04D06H" ,
#  "FORNIGHT"     : "01W03D12H" ,
#  "MONTH"   : "01W" ,
#  "YEAR"   : "03M" ,
#  "5_YEAR"   : "01Y06H" ,
#  "10_YEAR"   : "07Y06M" ,
#  "100_YEAR"   : "75Y" ,
#  "1000_YEAR"   : "750Y",
#  "HOUR"	: "45MIN",
#  "MINUTE"	: "45S",
#  "SECOND"	: "XS"
#}

PERIODMENTE_MAP = {
  "diariamente" : "P1D",
  "semanalmente" : "P1W",
  "mensualmente"   : "P1M",
  "bimensualmente"    : "P2M",
  "trimestralmente"    : "P3M",
  "semestralmente"     : "P6M",
  "anualmente"     : "P1Y",
  "bianualmente"     : "P2Y",
  "diario" : "P1D",
  "semanal" : "P1W",
  "mensual"   : "P1M",
  "bimensual"    : "P2M",
  "trimestral"    : "P3M",
  "semestral"     : "P6M",
  "anual"     : "P1Y",
  "bianual"     : "P2Y"
}
$PeriodAdv = CreateRegex(Keys(PERIODMENTE_MAP))

HOURS_MENOS_MAP = {
  "una": "12",
  "dos": "1",
  "tres": "2",
  "cuatro": "3",
  "cinco": "4",
  "seis": "5",
  "siete": "6",
  "ocho": "7",
  "nueve": "8",
  "diez": "9",
  "once": "10",
  "doce": "11",
  "1": "12",
  "2": "1",
  "3": "2",
  "4": "3",
  "5": "4",
  "6": "5",
  "7": "6",
  "8": "7",
  "9": "8",
  "10": "9",
  "11": "10",
  "12": "11"
}
$Hoursmenosmap = CreateRegex(Keys(HOURS_MENOS_MAP))


MINUTES_MENOS_MAP = {
  "uno": "59",
  "dos": "58",
  "tres": "57",
  "cuatro": "56",
  "cinco": "55",
  "seis": "54",
  "siete": "53",
  "ocho": "52",
  "nueve": "51",
  "diez": "50",
  "once": "49",
  "doce": "48",
  "trece": "47",
  "catorce": "46",
  "quince": "45",
  "dieciseis": "44",
  "dieciséis": "44",
  "diecisiete": "43",
  "dieciocho": "42",
  "diecinueve": "41",
  "veinte": "40",
  "veintiuno": "39",
  "veintidos": "38",
  "veintitres": "37",
  "veinticuatro": "36",
  "veinticinco": "35",
  "veintiseis": "34",
  "veintiséis": "34",
  "veintisiete": "33",
  "veintiocho": "32",
  "veintinueve": "31",
  "1": "59",
  "2": "58",
  "3": "57",
  "4": "56",
  "5": "55",
  "6": "54",
  "7": "53",
  "8": "52",
  "9": "51",
  "10": "50",
  "11": "49",
  "12": "48",
  "13": "47",
  "14": "46",
  "15": "45",
  "16": "44",
  "17": "43",
  "18": "42",
  "19": "41",
  "20": "40",
  "21": "39",
  "22": "38",
  "23": "37",
  "24": "36",
  "25": "35",
  "26": "34",
  "27": "33",
  "28": "32",
  "29": "31"
}
$Minutesmenosmap = CreateRegex(Keys(MINUTES_MENOS_MAP))


HOURS_MAP = {
  "una": "1",
  "uno": "1",
  "dos": "2",
  "tres": "3",
  "cuatro": "4",
  "cinco": "5",
  "seis": "6",
  "siete": "7",
  "ocho": "8",
  "nueve": "9",
  "diez": "10",
  "once": "11",
  "doce": "12",
  "1": "1",
  "2": "2",
  "3": "3",
  "4": "4",
  "5": "5",
  "6": "6",
  "7": "7",
  "8": "8",
  "9": "9",
  "10": "10",
  "11": "11",
  "12": "12"
}
$Hoursmap = CreateRegex(Keys(HOURS_MAP))

PARTDAY_MAP = {
  "mañana" : "MO",
  "madrugada" : "MO",
  "mediodía" : "MI",
  "tarde"   : "AF",
  "tardenoche"    : "EV",
  "noche"    : "NI"
}
$PDGranularity = CreateRegex(Keys(PARTDAY_MAP))



DGRANULARITY_UNIT_MAP = {
  "DAY" : "D" ,
  "WEEKEND"   : "WE" ,
  "WEEK"    : "W" ,
  "FORNIGHT"     : "D" ,
  "MONTH"   : "M" ,
  "2_MONTH"    : "M" ,  
  "3_MONTH"    : "Q" ,
  "4_MONTH"     : "T" ,
  "6_MONTH"   : "HALF" ,
  "YEAR"   : "Y" ,
  "2_YEAR"   : "Y" ,
  "3_YEAR"   : "Y" ,
  "5_YEAR"   : "Y" ,
  "10_YEAR"   : "Y" ,
  "100_YEAR"   : "Y" ,
  "1000_YEAR"   : "Y"
}

DGRANULARITY_AMOUNT_MAP = {
  "DAY" : 1 ,
  "WEEKEND"   : 2 ,
  "WEEK"    : 1 ,
  "FORNIGHT"     : 15 ,
  "MONTH"   : 1 ,
  "YEAR"   : 1 ,
  "2_MONTH"    : 2 ,  
  "3_MONTH"    : 3 ,
  "4_MONTH"     : 4 ,
  "6_MONTH"   : 6 ,
  "2_YEAR"   : 2 ,
  "3_YEAR"   : 3 ,
  "5_YEAR"   : 5 ,
  "10_YEAR"   : 10 ,
  "100_YEAR"   : 100  ,
  "1000_YEAR"   : 1000 
}



PERIOD_MAP = {
  "DAY" : "P" ,
  "WEEKEND"   : "P" ,
  "WEEK"    : "P" ,
  "FORNIGHT"     : "P" ,
  "MONTH"   : "P" ,
  "2_MONTH"    : "P" ,  
  "3_MONTH"    : "P" ,
  "4_MONTH"     : "P" ,
  "6_MONTH"   : "P" ,
  "YEAR"   : "P" ,
  "5_YEAR"   : "P" ,
  "10_YEAR"   : "P" ,
  "100_YEAR"   : "P" ,
  "1000_YEAR"   : "P",
  "SECOND"   : "PT",
  "MINUTE"   : "PT",
  "HOUR"   : "PT"
}

PMHOUR_MAP = {
  "1" : "13" ,
  "2"   : "14" ,
  "3"    : "15" ,
  "4"     : "16" ,
  "5"   : "17" ,
  "6"    : "18" ,  
  "7"    : "19" ,
  "8"     : "20" ,
  "9"   : "21" ,
  "10"   : "22" ,
  "11"   : "23" ,
  "12"   : "24" ,
  "13" : "13" ,
  "14"   : "14" ,
  "15"    : "15" ,
  "16"     : "16" ,
  "17"   : "17" ,
  "18"    : "18" ,  
  "19"    : "19" ,
  "20"     : "20" ,
  "21"   : "21" ,
  "22"   : "22" ,
  "23"   : "23" ,
  "0"   : "24"  
}

TGRANULARITY_MAP = {

  "segundo" : "SECOND",
  "segundos" : "SECOND",
  "minuto" : "MINUTE",
  "minutos" : "MINUTE",
  "hora"   : "HOUR",
  "horas"   : "HOUR"
}
$TGranularity = CreateRegex(Keys(TGRANULARITY_MAP))

TGRANULARITY_UNIT_MAP = {
  "SECOND" : "S",
  "MINUTE" : "MIN",
  "HOUR"   : "H"
}

TGRANULARITY_AMOUNT_MAP = {  
  "SECOND" : 1,
  "MINUTE" : 1,
  "HOUR"   : 1
}

$YEARN = ( /[12]\d\d\d/ );



YEARS_MAP = {
  "mil": 1000
}
$YEARDIG = CreateRegex(Keys(YEARS_MAP))

CENTS_MAP = {
  "ciento": 100,
  "doscientos": 200,
  "trescientos": 300,
  "cuatrocientos": 400,
  "quinientos": 500,
  "seiscientos": 600,
  "setecientos": 700,
  "ochocientos": 800,
  "novecientos": 900,
  "dosciento": 200,
  "tresciento": 300,
  "cuatrociento": 400,
  "quiniento": 500,
  "seisciento": 600,
  "seteciento": 700,
  "ochociento": 800,
  "noveciento": 900
}
$CENTDIG = CreateRegex(Keys(CENTS_MAP))

DECS_MAP = {
  "diez": 10,
  "10": 10,
  "veinte": 20,
  "20": 20,
  "treinta": 30,
  "30": 30,
  "cuarenta": 40,  
  "40": 40,
  "cincuenta": 50,
  "50": 50,
  "sesenta": 60,
  "60": 60,
  "setenta": 70,
  "70": 70,
  "ochenta": 80,
  "80": 80,
  "noventa": 90,
  "90": 90
}
$DECSDIG = CreateRegex(Keys(DECS_MAP))

UNS_MAP = {
  "un": 1,
  "una": 1,
  "uno": 1,
  "dos": 2,
  "tres": 3,
  "cuatro": 4,
  "cinco": 5,
  "seis": 6,
  "siete": 7,
  "ocho": 8,
  "nueve": 9
}
$UNSDIG = CreateRegex(Keys(UNS_MAP))

SPECIALS_MAP = {
  "once": 11,
  "doce": 12,
  "trece": 13,
  "catorce": 14,
  "quince": 15,
  "dieciseis": 16,
  "dieciséis": 16,
  "diecisiete": 17,
  "dieciocho": 18,
  "diecinueve": 19,
  "veintiuno": 21,
  "veintidos": 22,
  "veintitres": 23,
  "veinticuatro": 24,
  "veinticinco": 25,
  "veintiseis": 26,
  "veintiséis": 26,
  "veintisiete": 27,
  "veintiocho": 28,
  "veintinueve": 29
}

$SPECIALSDIG = CreateRegex(Keys(SPECIALS_MAP))


$ROMANS = (
  /I\.?/ =>  1 |
  /II\.?/ =>  2 |
  /III\.?/ =>  3 |
  /IV\.?/ =>  4 |
  /V\.?/ =>  5 |
  /VI\.?/ =>  6 |
  /VII\.?/ =>  7 |
  /VIII\.?/ =>  8 |
  /IX\.?/ =>  9 |
  /X\.?/ =>  10 |
  /XI\.?/ =>  11 |
  /XII\.?/ =>  12 |
  /XIII\.?/ =>  13 |
  /XIV\.?/ =>  14 |
  /XV\.?/ =>  15 |
  /XVI\.?/ =>  16 |
  /XVII\.?/ =>  17 |
  /XVIII\.?/ =>  18 |
  /XIX\.?/ =>  19 |
  /XX\.?/ =>  20 |
  /XXI\.?/ =>  21 |
  /XXII\.?/ =>  22 |
  /XXIII\.?/ =>  23 |
  /XXIV\.?/ =>  24 |
  /XXV\.?/ =>  25 |
  /XXVI\.?/ =>  26 |
  /XXVII\.?/ =>  27 |
  /XXVIII\.?/ =>  28 |
  /XXIX\.?/ =>  29 |
  /XXX\.?/ =>  30 

)



$DEICTIC2 = (
  /próximo/ => "+1" |
  /siguiente/   => "+1" |
  /ultimo/    => "-1" |
  /anterior/     => "-1" |
  /previo/   => "-1" |
  /posterior/    => "+1"
)





# Define ruleType to be over tokens
ENV.defaults["ruleType"] = "tokens"

#####################
# Basics (numbers)
#####################

# { ruleType:   "tokens",
#     pattern: ( ([{pos:"Z"}]) ) ,
# 	action: ( Annotate($0, "myRule", "Rule$ZNumber"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "mySTValue", $$1.lemma), Annotate($0, "myTValue", { type: "NUMBER", value: $$1.lemma }), Annotate($0, "myNERnormalized", :case{($$1.lemma.length == 1) => Concat("0", $$1.lemma), :else => $$1.lemma}) ),
# 	stage : 1 }

{ ruleType:   "tokens",
    pattern: ( [{lemma:/uno?/}]? [{lemma:"par"}] [{lemma:"de"}]  ) ,
	action: ( Annotate($0, "myRule", "Rule$parNumber"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "mySTValue", "2"), Annotate($0, "myTValue", 2), Annotate($0, "myNERnormalized", "2") ),
	stage : 5 }


{ ruleType:   "tokens",
    pattern: ( (/\d+/) ) ,
	action: ( Annotate($0, "myRule", "Rule$DNumber"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "mySTValue", $1[0].lemma), Annotate($0, "myTValue", { type: "NUMBER", value: $1[0].lemma }), Annotate($0, "myNERnormalized", :case{($1[0].lemma.length == 1) => Concat("0", $1[0].lemma), :else => $1[0].lemma}) ),
	stage : 1 }
{ ruleType:   "tokens",
    pattern: ( $ROMANS ) ,
	action: ( Annotate($0, "myRule", "Rule$RomanNumber"), Annotate($0, "myNUM", "myRNUMBER"), Annotate($0, "mySTValue", Format("%d", $$0.value)), Annotate($0, "myTValue", $$0.value), Annotate($0, "myNERnormalized", Format("%d", Subtract($$0.value,1))) ),
	stage : 1 }

# CHECK mirar que no se quede sola la y
# eg: mil cuatrocientos dieciseis
{ ruleType:   "tokens",
    pattern: ( ((?$yearunsdig [{lemma:/$UNSDIG/} & !{pos:/DI.*/}])? (?$yeardig [{lemma:/$YEARDIG/} && !{word:"miles"}]))? (?$centdig [{lemma:/$CENTDIG/}])? (?$decsdig [{lemma:/$DECSDIG/}])? (?$specialsdig [{lemma:/$SPECIALSDIG/}])? ((?$gry [{lemma:"y"}]) (?$unsdig [{lemma:/$UNSDIG/} & !{word:/[Uu][Nn][Oo][Ss]/}]))?),
	action: ( :case{ ($0[0].lemma != "y") =>
	
	(Annotate($0, "myRule", "Rule$LONGNUMBER"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "myTValue", Add( 
	:case { # We look at the Year digit
		($$yearunsdig == NIL && $$yeardig == NIL) => 0,
		($$yearunsdig == NIL && $$yeardig != NIL) => YEARS_MAP[$yeardig[0].lemma] ,		
		($$yearunsdig != NIL && $$yeardig != NIL) => Multiply(UNS_MAP[$yearunsdig[0].lemma],YEARS_MAP[$yeardig[0].lemma]) ,		
		:else => UNS_MAP[$yearunsdig[0].lemma]} , Add( #Special case, is a unit!
		:case {  # We look at the Century digit
			($$centdig == NIL ) => 0 ,
			:else => CENTS_MAP[$centdig[0].lemma]}, Add(
				:case { # We look at the Decade digit
					($$decsdig == NIL && $$specialsdig == NIL) => 0 ,
					($$decsdig == NIL && $$specialsdig != NIL) => SPECIALS_MAP[$specialsdig[0].lemma] ,
					($$decsdig != NIL && $$specialsdig == NIL) => DECS_MAP[$decsdig[0].lemma] ,
					:else => 0},  
						:case {  # We look at the Unit digit
							($$unsdig == NIL ) => 0 ,
							:else => UNS_MAP[$unsdig[0].lemma]}
				)
			)
		)
	), Annotate($0, "mySTValue", Format("%d", $0[0].myTValue)), Annotate($0, "myNERnormalized", Format("%02d", $0[0].myTValue))
	 );}),
	stage : 4 }

{ ruleType:   "tokens",
  pattern: ( $ORDINALS ),
  action: ( Annotate($0, "myRule", "Rule$ORDINALS"), Annotate($0, "myNER", "ORDINAL"), Annotate($0, "myNERnormalized", Format("%02d", $$0.value)), Annotate($0, "mySTValue", Format("%d", $$0.value)), Annotate($0, "myTValue", $$0.value)) ,
  stage : 1  } 

	
#####################
# Time-related basics (weekdays, months...)
#####################

{ ruleType:   "tokens",
  pattern: ( $SEASON ),
  action: ( Annotate($0, "myRule", "Rule$SEASON"), Annotate($0, "myNER", "SEASON"), Annotate($0, "myNERnormalized", Concat("-",$$0.value)), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat("XXXX-", $$0.value) )) ,
  stage : 1  }
  
{ ruleType:   "tokens",
  pattern: ( $MONTHS ),
  action: ( Annotate($0, "myRule", "Rule$MONTHS"), Annotate($0, "myNER", "MONTHS"), Annotate($0, "myNERnormalized", Format("%02d", $$0.value)), Annotate($0, "mySTValue", Format("%d", $$0.value)), Annotate($0, "myTValue", $$0.value), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat("XXXX-",Format("%02d", $$0.value)) )) ,
  stage : 1  } 
  
{ ruleType:   "tokens",
  pattern: ( [{lemma:"el"}]? [{lemma:"mes"}] [{lemma:"de"}] ([{myNER:"MONTHS"}]) ),
  action: ( Annotate($0, "myRule", "Rule$MONTHS"), Annotate($0, "myNER", "MONTHS"), Annotate($0, "myNERnormalized", $1[0].myNERnormalized), Annotate($0, "mySTValue", $1[0].mySTValue), Annotate($0, "myTValue", $1[0].myTValue), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", $1[0].timexValue )) ,
  stage : 2  } 
  
{ ruleType:   "tokens",
  pattern: ( $WEEKL ),
  action: ( Annotate($0, "myRule", "Rule$WEEKL"), Annotate($0, "myNER", "WEEKDAY"), Annotate($0, "myNERnormalized", Format("%02d", $$0.value)), Annotate($0, "mySTValue", Format("%d", $$0.value) ), Annotate($0, "myTValue", $$0.value), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat("XXXX-WXX-", Format("%02d", $$0.value))) ) ,
  stage : 1  } 
  
  { ruleType:   "tokens",
  pattern: ( /([L|l][O|o][S|s]|[C|c][A|a][D|d][A|a])/ ($WEEKL) ),
  action: ( Annotate($0, "myRule", "Rule$losWEEKL"), Annotate($0, "myNER", "WEEKDAY"), Annotate($0, "myNERnormalized", Format("%02d", $$1.value)), Annotate($0, "mySTValue", Format("%d", $$1.value) ), Annotate($0, "myTValue", $$1.value), Annotate($0, "timexType", "SET"), Annotate($0, "timexValue", Concat("XXXX-WXX-", Format("%02d", $$1.value))) ) ,
  stage : 1  }																					  
  
  
{ ruleType:   "tokens",
  pattern: ( $DAYMONTHN ),
  action: ( Annotate($0, "myRule", "Rule$DAYMONTHN"), Annotate($0, "myNER", "DAYMONTH"), Annotate($0, "myNERnormalized", Format("%02d", $$0.value)), Annotate($0, "mySTValue", Format("%d", $$0.value) ), Annotate($0, "myTValue", $$0.value), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Format("%02d", $$0.value)) ) ,
  stage : 1  } 
  
{ ruleType:   "tokens",
  pattern: ( $MONTHN ),
  action: ( Annotate($0, "myRule", "Rule$MONTHN"), Annotate($0, "myNER", "MONTHN"), Annotate($0, "myNERnormalized", Format("%02d", $$0.value)) , Annotate($0, "mySTValue", Format("%d", $$0.value) ), Annotate($0, "myTValue", $$0.value), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Format("%02d", $$0.value)) ) ,
  stage : 1  } 
  
{ ruleType:   "tokens",
  pattern: ( $YEARN ),
  action: ( Annotate($0, "myRule", "Rule$YEARN"), Annotate($0, "myNER", "YEAR"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "myNERnormalized", $$0.text), Annotate($0, "mySTValue", $$0.text) , Annotate($0, "myTValue", { type: "NUMBER", value: $$0.text }), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", $$0.text) ) ,
  stage : 1  }


{ ruleType:   "tokens",
  pattern: ( [{lemma:/$UNSDIG/}  & !{word:/[Uu][Nn][Oo][Ss]/}] ),
  action: ( Annotate($0, "myRule", "Rule$LetterNumber"), Annotate($0, "myNER", "myNUMBER"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "mySTValue", Format("%d", UNS_MAP[$0[0].lemma])), Annotate($0, "myTValue", UNS_MAP[$0[0].lemma]), Annotate($0, "myNERnormalized", Format("%02d", UNS_MAP[$0[0].lemma])) ) ,
  stage : 1  }  


#####################
# Years with letters
#####################


# eg: en el año mil cuarenta y dos
{ ruleType:   "tokens",
    pattern: ( (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"a"}] | [{lemma:"el"} & !{pos:/D.*/}] | [{lemma:"para"}]) ( [{pos:/D.*S.*/}]? [{lemma:"año"}]? (?$year [{myNUM:"myNUMBER"} && {mySTValue:/[12]\d\d\d/}]+ (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?)) [!{pos:/N.*/} && !{pos:/ZM.*/} && !{ner:"MONEY"}]),
	action: ( (Annotate($1, "myRule", "Rule$EnElAñoMyNumber"), Annotate($1, "myNER", "YEAR")), Annotate($1, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, $year[0].mySTValue)), Annotate($1, "myNERnormalized", $year[0].mySTValue), Annotate($1, "timexType", "DATE")),
	stage : 5 }	# Mejor como regla de filtrado lo de ZM (moneda), pero no va...
# eg: en el año mil cuarenta y dos
{ ruleType:   "tokens",
    pattern: ( [{myNER:"YEAR"}] (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"a"}] | [{lemma:"el"} & !{pos:/D.*/}] | [{lemma:"para"}]) ( [{pos:/D.*S.*/}]? [{lemma:"año"}]? (?$year [{myNUM:"myNUMBER"} && {mySTValue:/[12]\d\d\d/}]+ (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?)) [!{pos:/N.*/} && !{pos:/ZM.*/} && !{ner:"MONEY"}]),
	action: ( (Annotate($1, "myRule", ""), Annotate($1, "myNER", "")), Annotate($1, "timexValue", ""), Annotate($1, "timexType", "")),
	stage : 6 }	# Mejor como regla de filtrado lo de ZM (moneda), pero no va...					   
	
{ ruleType:   "tokens",
    pattern: ( (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"a"}] | [{lemma:"el"} & !{pos:/D.*/}] | [{lemma:"para"}]) ( [{pos:/D.*S.*/}]? [{lemma:"año"}] (?$year [{myNUM:"myNUMBER"} && {mySTValue:/[12]?\d?\d?\d/}]+ (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?))),
	action: ( (Annotate($1, "myRule", "Rule$EnElAñoMyNumber"), Annotate($1, "myNER", "YEAR")), Annotate($1, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%04d", $year[0].myTValue))), Annotate($1, "myNERnormalized", $year[0].mySTValue), Annotate($1, "timexType", "DATE")),
	stage : 5 }	
	
	
{ ruleType:   "tokens",
    pattern: ( (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"a"}] | [{lemma:"el"} & !{pos:/D.*/}] | [{lemma:"para"}]) ( [{pos:/D.*S.*/}]? [{lemma:"año"}] (?$year [{myNUM:"myNUMBER"} && {mySTValue:/[12]?\d?\d?\d/}]+ ((?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}]))) | (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}]))))))),
	action: ( (Annotate($1, "myRule", "Rule$EnElAñoMyNumber"), Annotate($1, "myNER", "YEAR")), Annotate($1, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%04d", $year[0].myTValue))), Annotate($1, "myNERnormalized", $year[0].mySTValue), Annotate($1, "timexType", "DATE")),
	stage : 5 }	
	
{ ruleType:   "tokens",
    pattern: ( (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"a"}] | [{lemma:"el"} & !{pos:/D.*/}] | [{lemma:"para"}]) ( [{pos:/D.*S.*/}]? [{lemma:"año"}]? (?$year [{myNUM:"myNUMBER"} && {mySTValue:/[12]?\d\d\d/}]+ ((?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}]))) | (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}]))))))),
	action: ( (Annotate($1, "myRule", "Rule$EnElAñoMyNumber"), Annotate($1, "myNER", "YEAR")), Annotate($1, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%04d", $year[0].myTValue))), Annotate($1, "myNERnormalized", $year[0].mySTValue), Annotate($1, "timexType", "DATE")),
	stage : 5 }	

# It adds its value as a myNERnormalized String to any number written with words	
#{ ruleType:   "tokens",
#    pattern: ( ([{myNUM:"myNUMBER"} & {myNERnormalized:NIL}]+) ),
#	action: ( Annotate($0, "myRule", "Rule$myNUMBER"), Annotate($$1, "myNERnormalized", $1[0].mySTValue)),
#	stage : 4 }


  


  

#####################
# Others
#####################

# eg: fin de semana / fines de semana
{ ruleType:   "tokens",
  pattern: ( ([{lemma:"fin"} & {pos:/.*S.*/}]) [{lemma:"de"}] [{lemma:"semana"}] ),
  action: ( Annotate($0, "myRule", "Rule$FinDeSemana"), Annotate($0, "myNER", "DGRANULARITY"), Annotate($0, "myNERnormalized", DGRANULARITY_MAP["finsemana"] ), Annotate($0, "myTType", "finsemana" ), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue", Concat("1",DGRANULARITY_UNIT_MAP[DGRANULARITY_MAP["finsemana"]])), Annotate($0, "Period", PERIOD_MAP["WEEKEND"]) ) ,
  stage : 1  }
  
{ ruleType:   "tokens",
  pattern: ( ([{lemma:"fin"} & {pos:/.*P.*/}]) [{lemma:"de"}] [{lemma:"semana"}] ),
  action: ( Annotate($0, "myRule", "Rule$FinDeSemana"), Annotate($0, "myNER", "DGRANULARITY"), Annotate($0, "myNERnormalized", DGRANULARITY_MAP["finsemana"] ), Annotate($0, "myTType", "finsemana" ), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue", Concat("X",DGRANULARITY_UNIT_MAP[DGRANULARITY_MAP["finsemana"]])), Annotate($0, "Period", PERIOD_MAP["WEEKEND"]) ) ,
  stage : 1  }

# eg: meses, dia...  
{ ruleType:   "tokens",
  pattern: ( [{lemma:/$DGranularity/} & !{myNER:"DGRANULARITY"}  & {pos:/.*P.*/}] ),
#  pattern: ( [{lemma:/$DGranularity/} & !{myNER:"DGRANULARITY"}  & !{ pos:/NP.*/ } & {pos:/.*P.*/}] ),
#    pattern: ( [{lemma:/$DGranularity/} & !{myNER:"DGRANULARITY"}  & !{ pos:/NP.*/ } & !{pos:/.*s.*/}] ),

  action: ( Annotate($0, "myRule", "Rule$GranularityP"), Annotate($0, "myNER", "DGRANULARITY"), Annotate($0, "myNERnormalized", DGRANULARITY_MAP[$0[0].lemma] ), Annotate($0, "myTType", $$0.text ), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue", Concat("X",DGRANULARITY_UNIT_MAP[DGRANULARITY_MAP[$0[0].lemma]])), Annotate($0, "Period", PERIOD_MAP[DGRANULARITY_MAP[$0[0].lemma]])  ) ,
  stage : 2  }
  
{ ruleType:   "tokens",
  pattern: ( [{lemma:/$DGranularity/} & !{myNER:"DGRANULARITY"}  & !{ pos:/NP.*/ } & {pos:/(.*S.*)|W/}] ),
#    pattern: ( [{lemma:/$DGranularity/} & !{myNER:"DGRANULARITY"}  & !{ pos:/NP.*/ } & !{pos:/.*P.*/}] ),

  action: ( Annotate($0, "myRule", "Rule$Granularity"), Annotate($0, "myNER", "DGRANULARITY"), Annotate($0, "myNERnormalized", DGRANULARITY_MAP[$0[0].lemma] ), Annotate($0, "myTType", $$0.text ), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue", Concat(DGRANULARITY_AMOUNT_MAP[DGRANULARITY_MAP[$0[0].lemma]],DGRANULARITY_UNIT_MAP[DGRANULARITY_MAP[$0[0].lemma]])), Annotate($0, "Period", PERIOD_MAP[DGRANULARITY_MAP[$0[0].lemma]])  ) ,
  stage : 2  }




#####################
# References
#####################


#quitamos "en el momento"
  
# eg: References to the past (TODO: ese momento puede usarse en futuro, ver tiempos verbales...)

{ ruleType:   "tokens",
  pattern: ([{lemma:"en"}]? (?$total ([{lemma:/d?el/}] [{word:/[P|p][A|a][S|s][A|a][D|d][O|o]/} & {pos:/N.*/}]) | ([{lemma:/d?el/}] [{lemma:"ayer"}]) | (([{lemma:"aquel"}]| [{lemma:"ese"}] ) ([{lemma:"momento"}]|[{lemma:"instante"}])) | ([{lemma:"antiguamente"}]) | ([{lemma:"antaño"}]) | (/[H|h][A|a][C|c][E|e]/ /[M|m][U|u][C|c][H|h][O|o][S|s]/ /[A|a][Ñ|ñ][O|o][S|s]/))),
  action: ( Annotate($total, "myRule", "Rule$PastRef"), Annotate($total, "timexType", "DATE"), Annotate($total, "timexValue", "PAST_REF") )  ,
  stage : 1  }  

  
# eg: References to the future (TODO: habria que meter "en unos + granularidad", ¿horas como?)
# quito ([{lemma:"en"}] /los|LOS/ /próximos|PRÓXIMOS/ /años|AÑOS/)
{ ruleType:   "tokens",
  action: ( Annotate($0, "myRule", "Rule$FutureRef"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "FUTURE_REF") )  ,
  pattern: (([{lemma:"el"}] ([{lemma:"día"}] [{lemma:"de"}])? [{lemma:"mañana"}]) | ([{lemma:"próximamente"}]) | ([{lemma:"en"}] /unos|UNOS/ [{lemma:"año"}]) | ([{lemma:"dentro"}] [{lemma:"de"}] /unos|UNOS/ /años|AÑOS/)  | ([{lemma:"en"}] /los|LOS/ /años|AÑOS/ /venideros|VENIDEROS/) | ([{lemma:"en"}] /los|LOS/ /años|AÑOS/ [{lemma:"que"}] /están|ESTÁN/ [{lemma:"por"}] [{lemma:"venir"}])),
  result: ( "DATE", "FUTURE_REF", "", "","Rule$FutureRef"),
  stage : 1000  }
  
  { ruleType:   "tokens",
  action: ( Annotate($1, "myRule", "Rule$FutureRef"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "FUTURE_REF") )  ,
  pattern: ([{lemma:"en"} | {lemma:"ser"}] ([{lemma:"el"}] [{lemma:"futuro"}]) [!{pos:/NC.*/}]),
  stage : 1000  }
  

{ ruleType:   "tokens",
  pattern: (([{lemma:"anteanoche"}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:"anoche"}]))),
  result: ("TIME", "anchor(TODAY,-,2D)TNI", "", "", "Rule$antesdeanoche"),
  stage : 1000  }
  
{ ruleType:   "tokens",
  pattern: ([{lemma:"anoche"}]),
  result: ("TIME", "anchor(TODAY,-,1D)TNI", "", "", "Rule$antesdeanoche"),
  stage : 1000  }

  
#####################
# Anchored
#####################
 

# eg: Pasado mañana / pasado
{ ruleType:   "tokens",
  pattern: ((?:[!{pos:/D.*/} & !{lemma:"haber"}]) (([{word:/[P|p][A|a][S|s][A|a][D|d][O|o]/} & !{pos:/NP.*/}] [{lemma:"mañana"}]) | ([{word:/[P|p][A|a][S|s][A|a][D|d][O|o]/} & !{pos:/NP.*/} & !{pos:/V.*/} & !{pos:/A.*/} & !{timexValue:"PAST_REF"}])) (?:[!{pos:/NC.*/}])),
  action: ( Annotate($1, "myRule", "Rule$PasadoMañana"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "anchor(TODAY,+,2D)"), Annotate($1, "myNERnormalized", "PASADO_MAÑANA") )  ,
  stage : 3  }
  
# eg: Pasado mañana / pasado
{ ruleType:   "tokens",
  pattern: ((?:[!{pos:/D.*/} & !{lemma:"haber"}]) (([{word:/[P|p][A|a][S|s][A|a][D|d][O|o]/} & !{pos:/NP.*/} & !{timexValue:"PAST_REF"}]) [{lemma:"mañana"}]?) (?:[!{pos:/NC.*/} & !{pos:/D.*/} & !{pos:/A.*/}])),
  action: ( Annotate($1, "myRule", "Rule$PasadoMañana"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "anchor(TODAY,+,2D)"), Annotate($1, "myNERnormalized", "PASADO_MAÑANA") )  ,
  stage : 3  }
  
  # eg: Pasado mañana / pasado
{ ruleType:   "tokens",
  pattern: ((([{word:/P[A|a][S|s][A|a][D|d][O|o]/} & !{pos:/NP.*/} & !{timexValue:"PAST_REF"}]) [{lemma:"mañana"}]?) (?:[!{pos:/N.*/} & !{pos:/D.*/} & !{pos:/A.*/}])),
  action: ( Annotate($1, "myRule", "Rule$PasadoMañana"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "anchor(TODAY,+,2D)"), Annotate($1, "myNERnormalized", "PASADO_MAÑANA") )  ,
  stage : 3  }
  
  # eg: Pasado mañana / pasado
{ ruleType:   "tokens",
  pattern: ([{myRule:"Rule$PasadoMañana"}]+),
  result: ("DATE", "anchor(TODAY,+,2D)", "", "", "Rule$PasadoMañana"),
  stage : 4  }

# eg: mañana
{ ruleType:   "tokens",
  pattern: ([!{word:/[P|p][A|a][S|s][A|a][D|d][O|o]/}] ([{lemma:"mañana"} & {pos:/RG.*/}])),
  action: ( Annotate($1, "myRule", "Rule$Mañana"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "anchor(TODAY,+,1D)"), Annotate($1, "myNERnormalized", "MAÑANA") )  ,
  stage : 2  }
  
  { ruleType:   "tokens",
  pattern: (([{word:/M[A|a][Ñ|ñ][A|a][N|n][A|a]/} & {pos:/RG.*/}])),
  action: ( Annotate($1, "myRule", "Rule$Mañana"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "anchor(TODAY,+,1D)"), Annotate($1, "myNERnormalized", "MAÑANA") )  ,
  stage : 2  }
 
# eg: mañana 
  { ruleType:   "tokens",
  pattern: ([{myRule:"Rule$Mañana"} | {myRule:"Rule$MañanaNoDet"}]+),
  result: ("DATE", "anchor(TODAY,+,1D)", "", "", "Rule$Mañana"),
  stage : 4  }
  
  # Falla con verbo delante:
  { ruleType:   "tokens",
  pattern: ([!{pos:/D.*/} & !{word:/[P|p][A|a][S|s][A|a][D|d][O|o]/}] ([{lemma:"mañana"}])),
  action: ( Annotate($1, "myRule", "Rule$MañanaNoDet"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "anchor(TODAY,+,1D)"), Annotate($1, "myNERnormalized", "MAÑANA") )  ,
  stage : 2  }
  
# eg: hoy
{ ruleType:   "tokens",
  pattern: (([{lemma:"a"} | {lemma:"el"} | {lemma:"al"}] [{lemma:"día"}] [{lemma:"de"}])? [{lemma:"hoy"}]),
  action: ( Annotate($0, "myRule", "Rule$Hoy"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "anchor(TODAY,+,0D)"), Annotate($0, "myNERnormalized", "HOY") )  ,
  stage : 2  }

  
  
  
# eg: References to the present
{ ruleType:   "tokens",
  pattern: ([{lemma:"anteayer"}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:"ayer"}])),
  action: ( Annotate($0, "myRule", "Rule$Anteayer"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "anchor(TODAY,-,2D)"), Annotate($0, "myNERnormalized", "ANTEAYER") )  ,
  stage : 2  }  

# eg: References to the present
{ ruleType:   "tokens",
  pattern: ([{lemma:"el"}]{0} [{lemma:"ayer"}]),
  action: ( Annotate($0, "myRule", "Rule$ElAyer"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "anchor(TODAY,-,1D)"), Annotate($0, "myNERnormalized", "AYER") )  ,
  stage : 2  }  

  
  
  
#####################
# Parts of the day
#####################
 

# eg: Mañana, tarde (MODSTIME)
# String PDGranularityES = "(?:madrugada|mañana|tarde|tardenoche|noche)";
{ ruleType:   "tokens",
  pattern: ((?:[{pos:/D.*/} | {lemma:/al/} | {lemma:/del/} | {pos:/AQ.*/}]) ([{lemma:"madrugada"} | {lemma:"mañana"}  | {lemma:"tarde"} | {lemma:"tardenoche"} | {lemma:"mediodía"} | {lemma:"noche"} & {pos:/NC.*/} & !{timexValue:/.+/}])),
  action: ( Annotate($0, "myRule", "Rule$PARTDAY"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", PARTDAY_MAP[$1[0].lemma]), Annotate($0, "myNERnormalized", "PARTDAY"), Annotate($0, "myTimePartDay", $0[0].timexValue)  )  ,
  result: ("TIME", Concat("anchor(TODAY,x,D)T",PARTDAY_MAP[$1[0].lemma]), "", "", "Rule$PARTDAY"),
  stage : 4  }

  
  
  
  
#####################
# SETS
#####################
 

# eg: Mensualmente
# String periodAdvES = GranularityES+"mente";
{ ruleType:   "composite",
  pattern: ([{lemma:/$PeriodAdv/} && !{pos:/N.*/}]),
  action: ( Annotate($0, "myRule", "Rule$GranMente"), Annotate($0, "timexType", "SET"), Annotate($0, "timexValue", PERIODMENTE_MAP[$0[0].lemma]), Annotate($0, "myNERnormalized", "SET_MENTE") )  ,
  result: ("SET", PERIODMENTE_MAP[$0[0].lemma], "", "", "Rule$GranMente"),
  stage : 1  }
  
# eg: Dos días cada 2 meses
{ ruleType:   "composite",
  pattern: ((?$times [{timexType:"DURATION"}]+) ([{lemma:"cada"}]) (?$gran [{timexType:"DURATION"}]+)),
  action: ( Annotate($0, "myRule", "Rule$XGranCadaXGran"), Annotate($0, "timexType", "SET"),  Annotate($0, "timexFreq", $times[0].timexValue), Annotate($0, "timexValue", Concat($gran[0].Period,$gran[0].timexValue)) )  ,
  #result: ("SET", Concat($gran[0].Period, $gran[0].timexValue), $times[0].timexValue, "", "Rule$XGranCadaXGran"),
  stage : 17  }
  
# eg: Dos días cada semana
{ ruleType:   "composite",
  pattern: ((?$times [{timexType:"DURATION"}]+)  (?: [{lemma:"cada"}] | [{lemma:"por"}] | [{lemma:"al"}] | [{lemma:"a"}]) (?:[{lemma:"el"}])? (?$gran [{myNER:"DGRANULARITY"}]+)),
  action: ( Annotate($0, "myRule", "Rule$XGranCadaGran"), Annotate($0, "timexType", "SET"),  Annotate($0, "timexFreq", $times[0].timexValue), Annotate($0, "timexValue", Concat($gran[0].Period, Format("%02d", DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized]),DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])) )  ,
  #result: ("SET", Concat($gran[0].Period, Format("%02d", DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized]),DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized]), $times[0].timexValue, "", "Rule$XGranCadaGran"),
  stage : 16  }
  
# eg: (Dos veces) cada 2 meses
{ ruleType:   "composite",
  pattern: ((?$times [{myNER:"TIMES"}]+)? (?: [{lemma:"cada"}]) (?$gran [{timexType:"DURATION"} & !{timexValue:/anchor.*/}]+)),
  action: ( Annotate($0, "myRule", "Rule$XVezCadaXGran"), Annotate($0, "timexType", "SET"),  Annotate($0, "timexFreq", :case{ ($$times != NIL) => $times[1].myNERnormalized, :else => ""} ), Annotate($0, "timexValue", Concat($gran[0].Period,$gran[0].timexValue)) )  ,
    #result: ("SET", Concat($gran[0].Period,$gran[0].timexValue), :case{ ($$times != NIL) => $times[1].myNERnormalized, :else => ""}, "", "Rule$XVezCadaXGran"),
  stage : 18  }
  
# eg: (Dos veces) cada/por semana
{ ruleType:   "composite",
  pattern: ((?$times [{myNER:"TIMES"}]+)? (?: [({lemma:"cada"} | {lemma:"por"} | {lemma:"al"} | {lemma:"a"}) & !{myNERnormalized:"HOY"}]) (?: [{lemma:"el"}])? (?$gran [{myNER:"DGRANULARITY"} & !{timexValue:/anchor.*/} & !{pos:/NC.*P.*/} & !{myNERnormalized:"HOY"}]+)),
  action: ( Annotate($0, "myRule", "Rule$XVezCadaGran"), Annotate($0, "timexType", "SET"), Annotate($0, "timexFreq", :case{ ($$times  != NIL) => $times[1].mySTValue, :else => ""} ) , Annotate($0, "timexValue", Concat(PERIOD_MAP[$gran[0].myNERnormalized],DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized],DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])) )  ,
    #result: ("SET", Concat(PERIOD_MAP[$gran[0].myNERnormalized],DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized],DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized]), :case{ ($$times  != NIL) => $times[1].myNERnormalized, :else => ""}, "", "Rule$XVezCadaGran"),
  stage : 18  }
  
# eg: Todas las semanas
{ ruleType:   "composite",
  pattern: (( [{lemma:"todo"} & {pos:/DI0.P0/}]) (?: [{pos:/DA0.P0/}]) ([{myNER:"DGRANULARITY"}]+)),
  action: ( Annotate($0, "myRule", "Rule$TodGran"), Annotate($0, "timexType", "SET"), Annotate($0, "timexValue", Concat(PERIOD_MAP[$2[0].myNERnormalized],DGRANULARITY_AMOUNT_MAP[$2[0].myNERnormalized],DGRANULARITY_UNIT_MAP[$2[0].myNERnormalized])) )  ,
  stage : 18  }

  





  
  
#####################
# Indefs
#####################

# eg: varios, algunos...
{ ruleType:   "tokens",
  pattern: ( ([{pos:/DI.*/} & (!{myNUM:"myNUMBER"} | {word:/unos|UNOS|Unos/}) & !{myNER:"WEEKDAY"}]+) [{pos:/A.*/}]*), 
  action: ( Annotate($0, "myRule", "Rule$Indef"), Annotate($0, "myNER", "INDEF") )  ,
  stage : 10  }

# eg: proximo
{ ruleType:   "tokens",
  pattern: ( ([{pos:/A.*/} & {lemma:/próximo|siguiente|posterior/}]+ | [{lemma:"que"}] [{word:/viene|VIENE/}]) ), 
  action: ( Annotate($0, "myRule", "Rule$FutureAdj"), Annotate($0, "myNER", "FUT_REF_Adj") )  ,
  stage : 9  }  
  
# eg: proximo
{ ruleType:   "tokens",
  pattern: ( ([{pos:/A.*/} & {lemma:/anterior|previo|último|precedente|pasado/}]+) ), 
  action: ( Annotate($0, "myRule", "Rule$PastAdj"), Annotate($0, "myNER", "PAS_REF_Adj") )  ,
  stage : 9  }  
  
# eg: demostrativo
{ ruleType:   "tokens",
  pattern: ( ([{pos:/DD.*/}]+) [{pos:/A.*/} & !{myNER:/.*_REF_Adj/}]*), 
  action: ( Annotate($0, "myRule", "Rule$Dem"), Annotate($0, "myNER", "DEM") )  ,
  stage : 10  }

#    String deictic2DurES = "(?:[M|m]uch[a|o]s|[U|u]n par de|[U|u]n[o|a]s cuant[o|a]s|[A|a]lgun[a|o]s|([U|u]n[a|o]s #)?[P|p]oc[a|o]s)";
#    String deictic1ES = #"(?:[E|e]l|[L|l]a|[L|l]os|[L|l]as|[E|e]s[e|a]|[E|e]st[e|a]|[E|e]s[o|a]s|[E|e]st[o|a]s|[A|a]quell[o|a]s|[A|a]quel|[P|p]asad[o|a](s#)?|[F|f]utur[o|a](s)?)";

#     //COMMENT
# 	String deictic1DurES = "(?:[E|e]l|[L|l]a|[L|l]os|[L|l]as|[E|e]s[e|a]|[E|e]st[e|a]|[E|e]s[o|a]s|[E|e]st[o|a]s|[A|a]quell[o|a]s|[A|a]quel|[P|p]asad[o|a](s)?|[F|f]utur[o|a](s)?)";
#     String deictES = "(" + deictic1ES + "|" + deictic2ES + "|" + deictic1ES + " " + deictic2ES + ")";
#     String deictDurES = "(((en el transcurso de|durante) )?" + deictic1DurES + "|" + deictic2DurES + "|" + deictic1DurES + " " + deictic2DurES + ")";



#####################
# Part day
#####################

# eg: mañana
{ ruleType:   "tokens",
  pattern: ([{lemma:"mañana"} & {pos:/NCS.*/}]), #Femenine for distinction with "el mañana" (unnecessary)
  action: ( Annotate($0, "myRule", "Rule$Mañ"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "anchor(TODAY,+,1D)"), Annotate($0, "myNERnormalized", "MAÑANA") )  ,
  stage : 2  }

  
  
  
  
  
  
  
  
  
  
  
  
  
#####################
# Complex dates
#####################  
  #     String longDateES = "(" + dayMonthNES + " de " + monthLES + "(?: (?:de )?" + yearNES + "))";
  # eg: dos dias
#{ ruleType:   "tokens",
#  pattern: ( /el/? /dia/? ([{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})]+) (?: /de/ | /del/) /mes/? /de/? ([{myNER:"MONTHS"}]) (?: /de/ | /del/ | /,/) /año/? ([{myNER:"YEAR"}]+)) ,
#  action: ( Annotate($0, "myRule", "Rule$DDdeMMdeYYYY"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}, "-", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}, "-", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"})) )  ,
#  stage : 11  }
  
  
#{ ruleType:   "tokens",
#  pattern: ( /el/? ([{myNER:"MONTHS"}]+) (?: /de/ | /del/ | /,/) /año/? ([{myNER:"YEAR"}])) ,
#  action: ( Annotate($0, "myRule", "Rule$MMdeYYYY"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XXXX"}, "-", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"})) )  ,
#  stage : 10  }
    
  
 #TODO: check normalization eu/EEUU, each part...
{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(1[0-9]|2[0-9]|3[0-1])[\/|-]0?([1-9])[\/|-]([1-2]\d\d\d)/),
result: ("DATE", Concat($$0.matchResults[0].word.group(3), "-0", $$0.matchResults[0].word.group(2), "-", $$0.matchResults[0].word.group(1)), "", "","Rule$DD-MM-YYYY") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(1[0-9]|2[0-9]|3[0-1])[\/|-](1[0-2])[\/|-]([1-2]\d\d\d)/),
result: ("DATE", Concat($$0.matchResults[0].word.group(3), "-", $$0.matchResults[0].word.group(2), "-", $$0.matchResults[0].word.group(1)), "", "","Rule$DD-MM-YYYY") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/0?([1-9])[\/|-]0?([1-9])[\/|-]([1-2]\d\d\d)/),
result: ("DATE", Concat($$0.matchResults[0].word.group(3), "-0", $$0.matchResults[0].word.group(2), "-0", $$0.matchResults[0].word.group(1)), "", "","Rule$DD-MM-YYYY") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/0?([1-9])[\/|-](1[0-2])[\/|-]([1-2]\d\d\d)/),
result: ("DATE", Concat($$0.matchResults[0].word.group(3), "-", $$0.matchResults[0].word.group(2), "-0", $$0.matchResults[0].word.group(1)), "", "","Rule$DD-MM-YYYY") }


# How to normalize?

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(1[0-9]|2[0-9]|3[0-1])[\/|-]0?([1-9])[\/|-](\d\d)/),
result: ("DATE", Concat("XX", $$0.matchResults[0].word.group(3), "-0", $$0.matchResults[0].word.group(2), "-", $$0.matchResults[0].word.group(1)), "", "", "Rule$DD-MM-YYYY") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(1[0-9]|2[0-9]|3[0-1])[\/|-](1[0-2])[\/|-](\d\d)/),
result: ("DATE", Concat("XX", $$0.matchResults[0].word.group(3), "-", $$0.matchResults[0].word.group(2), "-", $$0.matchResults[0].word.group(1)), "", "","Rule$DD-MM-YYYY") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/0?([1-9])[\/|-]0?([1-9])[\/|-](\d\d)/),
result: ("DATE", Concat("XX", $$0.matchResults[0].word.group(3), "-0", $$0.matchResults[0].word.group(2), "-0", $$0.matchResults[0].word.group(1)), "", "","Rule$DD-MM-YYYY") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/0?([1-9])[\/|-](1[0-2])[\/|-](\d\d)/),
result: ("DATE", Concat("XX", $$0.matchResults[0].word.group(3), "-", $$0.matchResults[0].word.group(2), "-0", $$0.matchResults[0].word.group(1)), "", "","Rule$DD-MM-YYYY") }




#####################
# Horas
##################### 


{ ruleType:   "tokens",
pattern: ([{word:/[Aa]/}]? [{word:/[Ll][aA][sS]?/}] ([{lemma:/$Hoursmap/}]) [{lemma:"menos"}] ([{myNUM:"myNUMBER"} & {mySTValue:/([1-5][0-9])|[1-9]/}]+)),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":", MINUTES_MENOS_MAP[$2[0].lemma]) ) , Annotate($0, "myRule", "Rule$12menos15"), Annotate($0, "myTimeHour", HOURS_MENOS_MAP[$1[0].lemma]), Annotate($0, "myTimeMinute", MINUTES_MENOS_MAP[$2[0].lemma]) )   ,
result: ("TIME", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":", MINUTES_MENOS_MAP[$2[0].lemma]), "", "", "Rule$12menos15") ,
 stage : 9  }
 
{ ruleType:   "tokens",
pattern: ([{word:/[Ll][aA][sS]?/}]? ([{myNUM:"myNUMBER"} & {mySTValue:/([1-5][0-9])|[1-9]/}]+) [{lemma:"para"}] [{word:/[Ll][aA][sS]?/}] ([{lemma:/$Hoursmap/}]) ),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$2[0].lemma], ":", MINUTES_MENOS_MAP[$1[0].lemma]) ) , Annotate($0, "myRule", "Rule$5parala1"), Annotate($0, "myTimeHour", HOURS_MENOS_MAP[$2[0].lemma]), Annotate($0, "myTimeMinute", MINUTES_MENOS_MAP[$1[0].lemma]) )   ,
result: ("TIME", Concat("T", HOURS_MENOS_MAP[$2[0].lemma], ":", MINUTES_MENOS_MAP[$1[0].lemma]), "", "", "Rule$5parala1") ,
 stage : 8  }
 
{ ruleType:   "tokens",
pattern: ([{word:/[C|c][U|u][A|a][R|r][T|t][O|o]/}] [{lemma:"para"}] [{word:/[Ll][aA][sS]?/}] ([{lemma:/$Hoursmap/}])),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":45" ) ) , Annotate($0, "myRule", "Rule$cuartoparalas2"), Annotate($0, "myTimeHour", HOURS_MENOS_MAP[$1[0].lemma]), Annotate($0, "myTimeMinute", "45") )   ,
result: ("TIME", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":45" ), "", "", "Rule$cuartoparalas2") ,
 stage : 8  }

{ ruleType:   "tokens",
pattern: ([{word:/[Aa]/}]? [{word:/[Ll][aA][sS]/}] ([{lemma:/$Hoursmap/}]) [{lemma:"y"}] [{word:/[C|c][U|u][A|a][R|r][T|t][O|o]/}]),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MAP[$1[0].lemma], ":15" ) , Annotate($0, "myRule", "Rule$12ycuarto"), Annotate($0, "myTimeHour", $1[0].mySTValue), Annotate($0, "myTimeMinute", "15") ) )   ,
result: ("TIME", Concat("T", $1[0].mySTValue, ":15"), "", "", "Rule$12ycuarto") ,
 stage : 10  }

{ ruleType:   "tokens",
pattern: ([{word:/[Aa]/}]? [{word:/[Ll][aA][sS]?/}] ([{lemma:/$Hoursmap/}]) [{lemma:"y"}] [{word:/[M|m][E|e][D|d][I|i][A|a]/}]),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MAP[$1[0].lemma], ":30") ) , Annotate($0, "myRule", "Rule$12ymedia"), Annotate($0, "myTimeHour", $1[0].mySTValue), Annotate($0, "myTimeMinute", "30") )   ,
result: ("TIME", Concat("T", $1[0].mySTValue, ":30"), "", "", "Rule$12ymedia") ,
 stage : 10  }

{ ruleType:   "tokens",
pattern: ([{word:/[Aa]/}]? [{word:/[Ll][aA][sS]?/}] ([{lemma:/$Hoursmap/}]) [{lemma:"menos"}] [{word:/[C|c][U|u][A|a][R|r][T|t][O|o]/}]),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":45" ) ) , Annotate($0, "myRule", "Rule$12menoscuarto"), Annotate($0, "myTimeHour", HOURS_MENOS_MAP[$1[0].lemma]), Annotate($0, "myTimeMinute", "45") )   ,
result: ("TIME", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":45" ), "", "", "Rule$12menoscuarto") ,
 stage : 10  }

{ ruleType:   "tokens",
pattern: ([{word:/[Aa]/}]? [{word:/[Ll][aA][sS]/}] ([{lemma:/$Hoursmap/}]) [{lemma:"y"}] ([{myNUM:"myNUMBER"} & {mySTValue:/([1-5][0-9])|[1-9]/}])),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":", MINUTES_MENOS_MAP[$2[0].lemma]) ) , Annotate($0, "myRule", "Rule$12y15"), Annotate($0, "myTimeHour", $1[0].mySTValue), Annotate($0, "myTimeMinute", $2[0].mySTValue) )   ,
result: ("TIME", Concat("T", $1[0].mySTValue, ":", $2[0].mySTValue), "", "", "Rule$12y15") ,
 stage : 10  }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: ((?:[{word:/[Ll][aA][sS]?/}])? (?$time /([1-9]|1[0-2])/ (/[P|p][M|m][.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/))),
action: ( Annotate($0, "myRule", "Rule$1_pm"), Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", PMHOUR_MAP[$$time.matchResults[0].word.group(1)], ":00") ), Annotate($0, "myTimeHour", PMHOUR_MAP[$$time.matchResults[0].word.group(1)]), Annotate($0, "myTimeMinute", "00") ),
result: ("TIME", Concat("T", PMHOUR_MAP[$$time.matchResults[0].word.group(1)], ":00"), "", "", "Rule$1_pm") ,
 stage : 10  }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: ((?:[{word:/[Ll][aA][sS]?/}])? (?$time /([1-9]|1[0-2])/ (/[A|a][M|m][.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/))),
action: ( Annotate($0, "myRule", "Rule$1_am"), Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", $$time.matchResults[0].word.group(1), ":00") ), Annotate($0, "myTimeHour", PMHOUR_MAP[$$time.matchResults[0].word.group(1)]), Annotate($0, "myTimeMinute", "00")  ),
result: ("TIME", Concat("T", $$time.matchResults[0].word.group(1), ":00"), "", "", "Rule$1_am") ,
 stage : 10  }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: ((?:[{word:/[Ll][aA][sS]?/}])? (?$time /([1-9]|1[0-2])[P|p][M|m][.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/)),
action: ( Annotate($0, "myRule", "Rule$1pm"), Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", PMHOUR_MAP[$$time.matchResults[0].word.group(1)], ":00") ), Annotate($0, "myTimeHour", PMHOUR_MAP[$$time.matchResults[0].word.group(1)]), Annotate($0, "myTimeMinute", "00")  ),
result: ("TIME", Concat("T", PMHOUR_MAP[$$time.matchResults[0].word.group(1)], ":00"), "", "", "Rule$1pm") ,
 stage : 10  }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: ((?:[{word:/[Ll][aA][sS]?/}])? (?$time /([1-9]|1[0-2])[A|a][M|m][.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/)),
action: ( Annotate($0, "myRule", "Rule$1am"), Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", $$time.matchResults[0].word.group(1), ":00") ), Annotate($0, "myTimeHour", $$time.matchResults[0].word.group(1)), Annotate($0, "myTimeMinute", "00")  ),
result: ("TIME", Concat("T", $$time.matchResults[0].word.group(1), ":00"), "", "", "Rule$1am") ,
 stage : 10  }
  
{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: ((?:[{word:/[Ll][aA][sS]?/}])? (?$time /(0?[0-9]|1[0-9]|2[0-4]):([0-5][0-9])[.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/)),
action: ( Annotate($0, "myRule", "Rule$1:30"), Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", $$time.matchResults[0].word.group(1),":", $$time.matchResults[0].word.group(2)) ), Annotate($0, "myTimeHour", $$time.matchResults[0].word.group(1)), Annotate($0, "myTimeMinute", $$time.matchResults[0].word.group(2))),
result: ("TIME", Concat("T", $$time.matchResults[0].word.group(1),":", $$time.matchResults[0].word.group(2)), "", "", "Rule$1:30") ,
 stage : 10  }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: ((?:[{word:/[Ll][aA][sS]?/}])? (?$time /(0?[0-9]|1[0-9]|2[0-4])\.([0-5][0-9])[.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/)),
action: ( Annotate($0, "myRule", "Rule$1.30"), Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", $$time.matchResults[0].word.group(1),":", $$time.matchResults[0].word.group(2)) ), Annotate($0, "myTimeHour", $$time.matchResults[0].word.group(1)), Annotate($0, "myTimeMinute", $$time.matchResults[0].word.group(2))),
result: ("TIME", Concat("T", $$time.matchResults[0].word.group(1),":", $$time.matchResults[0].word.group(2)), "", "", "Rule$1.30") ,
 stage : 10  }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: ((?:[{word:/[Ll][aA][sS]?/}])? (?$time /(0?[0-9]|1[0-9]|2[0-4])[H|h]([0-5][0-9])?[.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/)),
action: ( Annotate($0, "myRule", "Rule$1h30"), Annotate($0, "myTType", "TIME"),  Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", $$time.matchResults[0].word.group(1),":", :case{($$time.matchResults[0].word.group(2) != NIL) => $$time.matchResults[0].word.group(2), :else => "00" }) ), Annotate($0, "myTimeHour", $$time.matchResults[0].word.group(1)), Annotate($0, "myTimeMinute", :case{($$time.matchResults[0].word.group(2) != NIL) => $$time.matchResults[0].word.group(2), :else => "00" })),
result: ("TIME", Concat("T", $$time.matchResults[0].word.group(1),":", :case{($$time.matchResults[0].word.group(2) != NIL) => $$time.matchResults[0].word.group(2), :else => "00" }), "", "", "Rule$1h30") ,
 stage : 10  }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: ((?:[{word:/[Ll][aA][sS]?/}])? (?$time /(0?[0-9]|1[0-9]|2[0-4])[H|h]([0-5][0-9])?[.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/)),
action: ( Annotate($0, "myRule", "Rule$1h30"), Annotate($0, "myTType", "TIME"),  Annotate($0, "timexType", "TIME"),Annotate($0, "timexValue", Concat("T", $$time.matchResults[0].word.group(1),":", :case{($$time.matchResults[0].word.group(2) != NIL) => $$time.matchResults[0].word.group(2), :else => "00" }), Annotate($0, "myTimeHour", $$time.matchResults[0].word.group(1)), Annotate($0, "myTimeMinute", :case{($$time.matchResults[0].word.group(2) != NIL) => $$time.matchResults[0].word.group(2), :else => "00" }) ) ),
result: ("TIME", Concat("T", $$time.matchResults[0].word.group(1),":", :case{($$time.matchResults[0].word.group(2) != NIL) => $$time.matchResults[0].word.group(2), :else => "00" }), "", "", "Rule$1h30") ,
 stage : 10  }

{ ruleType:   "tokens",
pattern: ([{word:/[Ll][aA][sS]?/}] (/[1-9]|1[0-2]/) (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"por"}])? [{pos:/AQ.*/} | {pos:/D.*/} | {pos:/CC/}]* ([{myNERnormalized:"PARTDAY"}])+),
action: ( Annotate($0, "myRule", "Rule$3delatarde"), Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", Concat("T", :case{($2[0].timexValue == "AF") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "NI") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "EV") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "MI") => :case{($1[0].lemma != "12") => PMHOUR_MAP[$1[0].lemma], :else => $1[0].lemma }, :else => $1[0].lemma } } } }, ":00"), Annotate($0, "myTimeHour", :case{($2[0].timexValue == "AF") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "NI") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "EV") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "MI") => :case{($1[0].lemma != "12") => PMHOUR_MAP[$1[0].lemma], :else => $1[0].lemma }, :else => $1[0].lemma } } } }), Annotate($0, "myTimeMinute", "00") ) ),
result: ("TIME", Concat("T", :case{($2[0].timexValue == "AF") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "NI") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "EV") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "MI") => :case{($1[0].lemma != "12") => PMHOUR_MAP[$1[0].lemma], :else => $1[0].lemma }, :else => $1[0].lemma } } } }, ":00"), "", "", "Rule$3delatarde") ,
 stage : 10  }

#{ ruleType:   "tokens",
#matchedExpressionGroup: 1,
#pattern: ((?$total [{word:/[Aa]/}]? [{word:/[Ll][aA][sS]/}] (?$hora /[1-9]|1[0-2]/)) [!{pos:"NCFP000"}]),
#action: ( Annotate($0, "myRule", "Rule$alas3"), Annotate($total, "myTType", "TIME"), Annotate($total, "timexType", "TIME"), Annotate($total, #"timexValue", Concat("T", $hora[0].lemma, ":00"), Annotate($total, "myTimeHour", $hora[0].lemma), Annotate($total, "myTimeMinute", "00") ) ),		
#result: ("TIME", Concat("T", $hora[0].lemma , ":00"), "", "", "Rule$alas3"),
# stage : 9  }

{ ruleType:   "tokens",
matchedExpressionGroup: 1,
pattern: ([{word:/[Aa]/}]? (?$total [{word:/[Ll][aA][sS]?/}] (?$hour [{myNUM:"myNUMBER"} & {mySTValue:/[1-9]|1[0-2]/} & !{pos:DN0CP0} & !{timexType:"TIME"}]+)) [!{pos:"NCFP000"}]),
action: ( Annotate($total, "myRule", "Rule$las3"), Annotate($total, "myTType", "TIME"), Annotate($total, "timexValue", Concat("T", $hour[0].mySTValue, ":00")), Annotate($total, "timexType", "TIME"), Annotate($total, "myTimeHour", $hour[0].mySTValue), Annotate($total, "myTimeMinute", "00")  ),	
result: ("TIME", Concat("T", $hour[0].mySTValue , ":00"), "", "", "Rule$las3"),
 stage : 9  }

{ ruleType:   "tokens",
pattern: ([{word:/[Ll][aA][sS]?/}] (?$time [{myTType:"TIME"}]+) (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"por"}])? [{pos:/AQ.*/} | {pos:/D.*/} | {pos:/CC/}]* (?$pday [{myNERnormalized:"PARTDAY"}])+),
action: ( Annotate($0, "myRule", "Rule$3:20delatarde"), Annotate($0, "myTType", "TIME"), Annotate($0, "timexType", "TIME"), Annotate($0, "myTimeHour", :case{($pday[0].timexValue == "AF") => PMHOUR_MAP[$time[0].myTimeHour], :else => :case{($pday[0].timexValue == "NI") => PMHOUR_MAP[$time[0].myTimeHour], :else => :case{($pday[0].timexValue == "EV") => PMHOUR_MAP[$time[0].myTimeHour], :else => :case{($pday[0].timexValue == "MI") => :case{($pday[0].myTimeHour != "12") => PMHOUR_MAP[$time[0].myTimeHour], :else => $1[0].mySTValue }, :else => $time[0].myTimeHour } } } }), Annotate($0, "myTimeMinute", $time[0].myTimeMinute), Annotate($0, "myTimePartDay", $pday[0].timexValue) , Annotate($0, "timexValue", Concat("T", :case{($pday[0].timexValue == "AF") => PMHOUR_MAP[$time[0].myTimeHour], :else => :case{($pday[0].timexValue == "NI") => PMHOUR_MAP[$time[0].myTimeHour], :else => :case{($pday[0].timexValue == "EV") => PMHOUR_MAP[$time[0].myTimeHour], :else => :case{($pday[0].timexValue == "MI") => :case{($pday[0].myTimeHour != "12") => PMHOUR_MAP[$time[0].myTimeHour], :else => $1[0].mySTValue }, :else => $time[0].myTimeHour } } } }, ":", $time[0].myTimeMinute)) ),
result: ("TIME", Concat("T", :case{($pday[0].timexValue == "AF") => PMHOUR_MAP[$time[0].myTimeHour], :else => :case{($pday[0].timexValue == "NI") => PMHOUR_MAP[$time[0].myTimeHour], :else => :case{($pday[0].timexValue == "EV") => PMHOUR_MAP[$time[0].myTimeHour], :else => :case{($pday[0].timexValue == "MI") => :case{($pday[0].myTimeHour != "12") => PMHOUR_MAP[$time[0].myTimeHour], :else => $1[0].mySTValue }, :else => $time[0].myTimeHour } } } }, ":", $time[0].myTimeMinute), "", "", "Rule$3:20delatarde") ,
 stage : 11  }

{ ruleType:   "tokens",
pattern: ([{word:/[Ll][aA][sS]?/}] ([{myNUM:"myNUMBER"} & {mySTValue:/[1-9]|1[0-2]/} & !{pos:DN0CP0}]) (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"por"}])? [{pos:/AQ.*/} | {pos:/D.*/} | {pos:/CC/}]* ([{myNERnormalized:"PARTDAY"}])+),
action: ( Annotate($0, "myRule", "Rule$tresdelatarde"), Annotate($0, "timexType", "TIME"), Annotate($0, "myTimeHour", :case{($2[0].timexValue == "AF") => PMHOUR_MAP[$1[0].mySTValue], :else => :case{($2[0].timexValue == "NI") => PMHOUR_MAP[$1[0].mySTValue], :else => :case{($2[0].timexValue == "EV") => PMHOUR_MAP[$1[0].mySTValue], :else => :case{($2[0].timexValue == "MI") => :case{($1[0].mySTValue != "12") => PMHOUR_MAP[$1[0].mySTValue], :else => $1[0].mySTValue }, :else => $1[0].mySTValue } } } }), Annotate($0, "myTimeMinute", "00"), Annotate($0, "myTimePartDay", $2[0].timexValue)),
result: ("TIME", Concat("T", :case{($2[0].timexValue == "AF") => PMHOUR_MAP[$1[0].mySTValue], :else => :case{($2[0].timexValue == "NI") => PMHOUR_MAP[$1[0].mySTValue], :else => :case{($2[0].timexValue == "EV") => PMHOUR_MAP[$1[0].mySTValue], :else => :case{($2[0].timexValue == "MI") => :case{($1[0].mySTValue != "12") => PMHOUR_MAP[$1[0].mySTValue], :else => $1[0].mySTValue }, :else => $1[0].mySTValue } } } }, ":00"), "", "", "Rule$tresdelatarde"),
 stage : 8  }
  
#composite:

#####################
# Number + TGranularity
#####################

# eg: horas
{ ruleType:   "tokens",
  pattern: ( [(/$TGranularity/ & {pos:/NC.*/} & {pos:/.*P.*/})] ), # To avoid confusion with second (time measure unit and ordinal)
  action: ( Annotate($0, "myRule", "Rule$TGranularity"), Annotate($0, "myNER", "TGRANULARITY"), Annotate($0, "myNERnormalized", TGRANULARITY_MAP[$0[0].lemma] ), Annotate($0, "myTType", $$0.text ), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue", Concat("X",TGRANULARITY_UNIT_MAP[TGRANULARITY_MAP[$0[0].lemma]])), Annotate($0, "Period", PERIOD_MAP[TGRANULARITY_MAP[$0[0].lemma]] )) ,
  stage : 2  }
  
{ ruleType:   "tokens",
  pattern: ( [(/$TGranularity/ & {pos:/NC.*/} & {pos:/.*S.*/})] ), # To avoid confusion with second (time measure unit and ordinal)
  action: ( Annotate($0, "myRule", "Rule$TGranularity"), Annotate($0, "myNER", "TGRANULARITY"), Annotate($0, "myNERnormalized", TGRANULARITY_MAP[$0[0].lemma] ), Annotate($0, "myTType", $$0.text ), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue", Concat(TGRANULARITY_AMOUNT_MAP[TGRANULARITY_MAP[$0[0].lemma]],TGRANULARITY_UNIT_MAP[TGRANULARITY_MAP[$0[0].lemma]])), Annotate($0, "Period", PERIOD_MAP[TGRANULARITY_MAP[$0[0].lemma]] ) ),
  stage : 2  }
 
# eg: dos horas
{ ruleType:   "tokens",
  pattern: ( ([{myNUM:"myNUMBER"}]+) (?$gran [{myNER:"TGRANULARITY"}]+) (?$plus [{lemma:"y"}] (?$added [{lemma:"medio"}] || [{word:/[C|c][U|u][A|a][R|r][T|t][O|o]/}] || [{myNUM:"myNUMBER"} && {mySTValue:/0?3/}] [{word:/[C|c][U|u][A|a][R|r][T|t][O|o][S|s]/}]))? ),
  action: ( Annotate($0, "myRule", "Rule$NUMTGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat($1[0].mySTValue, :case{($plus != NIL) => :case{($added[0].lemma == "medio") => ".5", ($added[0].mySTValue != "03" && $added[0].mySTValue != "3") => ".25", :else => ".75"}, :else => ""}, TGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])), Annotate($0, DURATION_MAP[$gran[0].myNERnormalized], $gran[0].timexValue), Annotate($0, "Period", "PT") ) , 
  stage : 15  }
  
  
  
  
  
  
 # eg: varias/algunas horas
{ ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.*/} | {pos:/SPCM.*/}]? ([{myNER:"INDEF"}]+) ([{myNER:"TGRANULARITY"}]) ),
  action: ( Annotate($0, "myRule", "Rule$INDEFTGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat("X", TGRANULARITY_UNIT_MAP[$2[0].myNERnormalized])), Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue), Annotate($0, "Period", "PT") ) , 
  stage : 15  }
  
 # eg: las próximas horas/decadas (indef)
{ ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.*/} | {pos:/SPCM.*/}]? ([{myNER:"FUT_REF_Adj"} & {pos:/A.*P.*/}]+) (?$gran [{myNER:"[TD]GRANULARITY"}]) ),
  action: ( Annotate($0, "myRule", "Rule$proximasGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,-,",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")") ) ),  
  stage : 15  }
  
  
  #### este (TODO: igual para WEEKDAY?)

#{ ruleType:   "tokens",
#  pattern: ( (?$total (?$rel [{pos:/D[A|D].*S.*/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$gran [{myNER:"DGRANULARITY"} & !{timexType:"SET"} & !{myNERnormalized:/1000?_YEAR/} & !{pos:/.+P.+/}]+)) [!{myNER:"DAYMONTH"} & !{myNER:"MONTHN"} & !{myNUM:/my[R]?NUMBER/}]),
#  action: ( :case{($$rel != NIL) => (Annotate($total, "myRule", "Rule$este"), Annotate($total, "timexType", "DATE"), Annotate($total, "timexValue", Concat("anchor(TODAY,x,", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")), Annotate($total, "Period", $gran[0].Period)), :else => (Annotate($total, "myRule", "Rule$gran"), Annotate($total, "timexType", "DURATION"), Annotate($total, "timexValue", Concat(DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized],DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])), Annotate($total, "Period", $gran[0].Period))}   
#   )  ,
#  stage : 20  }

{ ruleType:   "tokens",
  pattern: ( (?$total (?$rel [({pos:/D[A|D].*S.*/} | {pos:/SPCMS/}) & !{myNER:/.+_Adj/}] [({pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}) & !{myNER:/.+_Adj/}]*) (?$gran [{myNER:"DGRANULARITY"} & !{timexType:"SET"} & !{myNERnormalized:/1000?_YEAR/} & !{pos:/.+P.+/}]+)) [!{myNER:"DAYMONTH"} & !{myNER:"MONTHN"} & !{myNUM:/my[R]?NUMBER/} & !{myNER:/.+_Adj/}]),
  action: ( Annotate($total, "myRule", "Rule$este"), Annotate($total, "timexType", "DATE"), Annotate($total, "timexValue", Concat("anchor(TODAY,x,", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")), Annotate($total, "Period", $gran[0].Period)  
   )  ,
  stage : 20  }
  
	{ ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$gran [{word:"siglo"} & !{pos:/.+P.+/} & !{timexType:"DURATION"}]+) (?$num [{myNUM:"myNUMBER"} || {myNER:"ORDINAL"}]+) (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))? (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?),
  action: ( Annotate($0, "myRule", "Rule$esteSiglo20"), Annotate($0, "myNER", "Rule$esteSiglo20"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%02d", Subtract($num[0].myTValue,1))))),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%02d", Subtract($num[0].myTValue,1))), "", "", "Rule$esteSiglo20")  ,
  stage : 20  }	

{ ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$num (([{myNUM:"myNUMBER"} & {mySTValue:/\d?\d/}]+) | ([{myNER:"ORDINAL"}]+))) ((?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}]))) | (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}]))))),
  action: ( Annotate($0, "myRule", "Rule$20AC"), Annotate($0, "myNER", "Rule$esteSiglo20"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%02d", Subtract($num[0].myTValue,1))))),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%02d", Subtract($num[0].myTValue,1))), "", "", "Rule$20AC")  ,
  stage : 20  }	


	{ ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$gran [{word:"milenio"} & !{pos:/.+P.+/}]+) (?$num [{myNUM:"myNUMBER"} || {myNER:"ORDINAL"}]+) (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))? (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?),
  action: ( Annotate($0, "myRule", "Rule$esteMilenio1"), Annotate($0, "myNER", "Rule$esteSiglo20"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%01d", Subtract($num[0].myTValue,1))))),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%02d", Subtract($num[0].myTValue,1))), "", "", "Rule$esteMilenio1")  ,
  stage : 20  }

	{ ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$num [{myNER:"ORDINAL"}]+) (?$gran [{word:"milenio"} & !{pos:/.+P.+/}]+) (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))? (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?),
  action: ( Annotate($0, "myRule", "Rule$estePrimerMilenio"), Annotate($0, "myNER", "Rule$estePrimerMilenio"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%01d", Subtract($num[0].myTValue,1))))),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%02d", Subtract($num[0].myTValue,1))), "", "", "Rule$estePrimerMilenio")  ,
  stage : 20  }	 
  
  	{ ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$num [{myNER:"ORDINAL"}]+) (?$gran [{myNER:"DGRANULARITY"} & {myNERnormalized:/\d_MONTH/} & !{pos:/.+P.+/}]+)),
  action: ( Annotate($0, "myRule", "Rule$estePrimerCuatrimestre"), Annotate($0, "myNER", "Rule$estePrimerCuatrimestre"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat("anchor(TODAY,x,",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],$num[0].mySTValue,")"))),
result: ("DATE", Concat("anchor(TODAY,x,",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],$num[0].mySTValue,")"), "", "", "Rule$estePrimerCuatrimestre")  ,
  stage : 20  }
  
  
  	{ ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$gran [{word:"siglo"} & !{pos:/.+P.+/}]+) (?$num [{myNUM:"myNUMBER"} || {myNER:"ORDINAL"}]+) (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))? (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?),
  action: ( Annotate($0, "myRule", "Rule$esteSiglo20"), Annotate($0, "myNER", "Rule$esteSiglo20"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%02d", Subtract($num[0].myTValue,1))))),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""}, Format("%02d", Subtract($num[0].myTValue,1))), "", "", "Rule$esteSiglo20")  ,
  stage : 20  }
  
  	{ ruleType:   "tokens",
  pattern: ( ((?$rel [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$gran [{word:"siglo"} & !{pos:/.+P.+/} & !{timexType:"DURATION"}]+)) [!{myNUM:/my[R]?NUMBER/}]),
  action: ( Annotate($1, "myRule", "Rule$esteSiglo"), Annotate($1, "myNER", "Rule$esteSiglo"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "anchor(TODAY,x,CENT)")),
  stage : 20  }		


  
  { ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.*S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$gran [{word:"siglo"} & !{pos:/.+P.+/}]+) (?$num [{myNUM:"myRNUMBER"}]) (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))? (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?),
  action: ( Annotate($0, "myRule", "Rule$esteSigloXX"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""},$num[0].myNERnormalized))),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""},$num[0].myNERnormalized), "", "", "Rule$esteSigloXX")  ,
  stage : 20  } 
  
    { ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.*S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$num [{myNUM:"myRNUMBER"}]) ((?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}]))) | (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))) ),
  action: ( Annotate($0, "myRule", "Rule$elXXAC"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""},$num[0].myNERnormalized))),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""},$num[0].myNERnormalized), "", "", "Rule$elXXAC")  ,
  stage : 20  } 
  
{ ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.*S0/} | {pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$gran [{word:"milenio"} & !{pos:/.+P.+/}]+) (?$num [{myNUM:"myRNUMBER"}]) (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))? (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?),
  action: ( Annotate($0, "myRule", "Rule$esteMilenioI"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""},$num[0].myNERnormalized))),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""},$num[0].myNERnormalized), "", "", "Rule$esteMilenioI")  ,
  stage : 20  } 
  
  { ruleType:   "tokens",
  pattern: ( (?$rel [{pos:/D[A|D]0.S0/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$gran [{word:"año"} & !{pos:/.+P.+/}]+) (?$num [{myNUM:"myNUMBER"} & !{myRule:/Rule\$DDdeMMdeYYYY(Com)?/}]+) (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))? (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?),
  action: ( Annotate($0, "myRule", "Rule$esteaño2000"), Annotate($0, "timexType", "DATE"), Annotate($0, "myNER", "YEAR"), Annotate($0, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, $num[0].mySTValue)), Annotate($0, "Period", $gran[0].Period)),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""},$num[0].mySTValue), "", "", "Rule$esteaño2000")  ,
  stage : 200  }
  
    { ruleType:   "tokens",
  pattern: ( [!{timexType:"DATE"}] (?$total (?$rel [{pos:/SPCMS/}] [{pos:/D.+S.+/} | {pos:/AQ.+S.+/} | {pos:"FC"} | {pos:"CC"}]*)? (?$gran [{word:"año"} & !{pos:/.+P.+/}]+) (?$num [{myNUM:"myNUMBER"} & !{myRule:/Rule\$DDdeMMdeYYYY(Com)?/}]+) (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))? (?$dc ([{word:/[D|d]\.?[C|c]\.?/}] | ([{lemma:"después"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))?)),
  action: ( Annotate($total, "myRule", "Rule$esteaño2000bis"), Annotate($0, "myNER", "YEAR"), Annotate($total, "timexType", "DATE"), Annotate($total, "timexValue", Concat(:case{($$AC != NIL) => "BC", :else => ""}, $num[0].mySTValue)), Annotate($total, "Period", $gran[0].Period)),
result: ("DATE", Concat(:case{($$AC != NIL) => "BC", :else => ""},$num[0].mySTValue), "", "", "Rule$esteaño2000bis")  ,
  stage : 200  }
  
  
  { ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.*/} | {pos:/SPC.*/}]?  ([{myNER:"PAS_REF_Adj"} & {pos:/A.*P.*/}]+) (?$gran [{myNER:"[TD]GRANULARITY"}]) ),
  action: ( Annotate($0, "myRule", "Rule$anterioresGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,-,",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")") ) ), 
  stage : 15  }
  
 # eg: las horas que vienen (indef)
{ ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.*/} | {pos:/SPC.*/}]?  (?$gran [{myNER:"TGRANULARITY"}]) ([{myNER:"FUT_REF_Adj"} & {pos:/A.*P.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$Granularityqueviene"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,-,",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")") ) ), 
  stage : 15  }
  
  
 { ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.*/} | {pos:/SPC.*/}]?  (?$gran [{myNER:"TGRANULARITY"}]) ([{myNER:"PAS_REF_Adj"} & {pos:/A.*P.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$Granularityanteriores"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,-,",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")") ) ), 
  stage : 15  }
 
 
 
 #TODO: poco claro como habria que normalizar esto con horas...
 # eg: la próxima hora (anchor)
{ ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.S0/} | {pos:/SPC.*S/}]? ([{myNER:/("FUT_REF_Adj"|"ORDINAL")/} & {pos:/A.*S.*/}]+) (?$gran [{myNER:/TGRANULARITY/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$proximoTGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat("PT1", TGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPC.*S/}]? ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myNER:/TGRANULARITY/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$anteriorTGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat("PT1", TGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPC.*S/}]? (?$gran [{myNER:/TGRANULARITY/}]+) ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$proximoGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat("PT1", TGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPC.*S/}]? (?$gran [{myNER:/TGRANULARITY/}]+) ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$anteriorGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat("PT1", TGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])) ) , 
  stage : 15  }
  
  
  # eg: la próxima semana
{ ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.S0/} | {pos:/SPC.*S/}]? ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myNER:/DGRANULARITY/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$proximoGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,+,1", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPC.*S/}]? ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myNER:/DGRANULARITY/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$anteriorGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,-,1", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPC.*S/}]? (?$gran [{myNER:/DGRANULARITY/}]+) ([{myNER:"FUT_REF_Adj"} & !{pos:/A.*P.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$proximoGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,+,1", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPC.*S/}]? (?$gran [{myNER:/DGRANULARITY/}]+) ([{myNER:"PAS_REF_Adj"} & {pos:/A.*P.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$anteriorGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,-,1", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")) ) , 
  stage : 15  }
  
  
  
  # weekdays
  
  
    { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myNER:"WEEKDAY"}]) ),
  action: ( Annotate($0, "myRule", "Rule$anteriorWeekD"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,-,", $gran[0].mySTValue,"DAYW)")) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myNER:"WEEKDAY"}]) ),
  action: ( Annotate($0, "myRule", "Rule$proximoWeekD"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,+,", $gran[0].mySTValue,"DAYW)")) ) , 
  stage : 15  }
  
      { ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? (?$gran [{myNER:"WEEKDAY"}]) ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+)),
  action: ( Annotate($0, "myRule", "Rule$anteriorWeekD"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,-,", $gran[0].mySTValue,"DAYW)")) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? (?$gran [{myNER:"WEEKDAY"}]) ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$proximoWeekD"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,+,", $gran[0].mySTValue,"DAYW)")) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}] [{myNER:"DEM"} | {myNER:"INDEF"}]* (?$gran [{myNER:"WEEKDAY"} & !{myRule:"Rule$proximoWeekD"} & !{myRule:"Rule$anteriorWeekD"}] ) ),
  action: ( Annotate($0, "myRule", "Rule$esteWeekD"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,z,", $gran[0].mySTValue,"DAYW)")) ) , 
  stage : 16  }
  
  
  # months
  
  
    { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myNER:"MONTHS"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$anteriorMonthS"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("DWanchor(-,", $gran[0].mySTValue,"MONTHS)")) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myNER:"MONTHS"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$proximoMonthS"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("DWanchor(+,", $gran[0].mySTValue,"MONTHS)")) ) , 
  stage : 15  }
  
      { ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? (?$gran [{myNER:"MONTHS"}]+) ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+)),
  action: ( Annotate($0, "myRule", "Rule$anteriorMonthS"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("DWanchor(-,", $gran[0].mySTValue,"MONTHS)")) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? (?$gran [{myNER:"MONTHS"}]+) ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$MonthSproximo"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("DWanchor(+,", $gran[0].mySTValue,"MONTHS)")) ) , 
  stage : 15  }
  
  
  
  
  
  
  
  
# eg: una hora
#{ ruleType:   "tokens",
#  pattern: ( ([{lemma:"uno"}]) ([{myNER:"TGRANULARITY"}]) ),
#      action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat($1[0].mySTValue, TGRANULARITY_UNIT_MAP[$2[0].myNERnormalized])), Annotate($0, "MyRule",  "Rule$unTGranularity"), Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue ), Annotate($0, "Period", PERIOD_MAP[$2[0].myNERnormalized]) ) , 
#  stage : 15  }

# eg: media hora /cuarto de hora
 { ruleType:   "tokens",
   pattern: ( (?$added [{lemma:"medio"}] || [{myNUM:"myNUMBER"} && {mySTValue:"3"}] [{word:/[C|c][U|u][A|a][R|r][T|t][O|o][S|s]/}] [{lemma:"de"}] || [{word:/[C|c][U|u][A|a][R|r][T|t][O|o]/}] [{lemma:"de"}]) (?$granu [{myNER:"TGRANULARITY"}]+) ),
      action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$MediaHora"), Annotate($0, "timexValue", :case{($added[0].lemma == "medio") => HALF_DURATION_MAP[$granu[0].myNERnormalized], ($added[0].mySTValue == "3") => TQUARTER_DURATION_MAP[$granu[0].myNERnormalized], :else => QUARTER_DURATION_MAP[$granu[0].myNERnormalized]}), Annotate($0, DURATION_MAP[$granu[0].myNERnormalized], $granu[0].timexValue), Annotate($0, "Period", :case{($granu[0].myNERnormalized == "DAY") => PERIOD_MAP["HOUR"], :else => $granu[0].Period}) ) , 
	  stage : 14  }

  
  
#####################
# Number + DGranularity
##################### 
 
  # eg: dos dias
{ ruleType:   "tokens",
  pattern: ( ([{myNUM:"myNUMBER"}]+)  (?$gran [{myNER:"DGRANULARITY"}]+) (?$plus [{lemma:"y"}] (?$added [{lemma:"medio"}] | [{word:/[C|c][U|u][A|a][R|r][T|t][O|o]/}] | [{myNUM:"myNUMBER"} && {mySTValue:/0?3/}] [{word:/[C|c][U|u][A|a][R|r][T|t][O|o][S|s]/}]))? ),
    action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$DosDias"), Annotate($0, "timexValue", :case{($plus != NIL) => :case{($added[0].lemma == "medio") => Concat(Add(Multiply(DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized], $1[0].myTValue), Multiply(DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized], 0.5)),DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized]), ($added[0].mySTValue != "03" && $added[0].mySTValue != "3") => Concat(Add(Multiply(DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized], $1[0].myTValue), Multiply(DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized], 0.25)),DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized]), :else => Concat(Add(Multiply(DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized], $1[0].myTValue), Multiply(DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized], 0.75)),DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])}, :else => Concat(Multiply(DGRANULARITY_AMOUNT_MAP[$gran[0].myNERnormalized], $1[0].myTValue),DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])}), Annotate($0, DURATION_MAP[$gran[0].myNERnormalized], $gran[0].timexValue), Annotate($0, "Period", $gran[0].Period) ) ,
  stage : 15  }

  
 
 { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.*P.*/} | {pos:/SPCM.*/}]? ([{myNER:"INDEF"}]+) ([{myNER:"DGRANULARITY"} & !{pos:/.*S.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$INDEFDGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat("X", DGRANULARITY_UNIT_MAP[$2[0].myNERnormalized])), Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue), Annotate($0, "Period", $2[0].Period) ) , 
  result: ("DURATION", Concat("X", DGRANULARITY_UNIT_MAP[$2[0].myNERnormalized]), "", "", "Rule$INDEFDGranularity"),
  stage : 15  }
 
# eg: medio dia /cuarto de año
 { ruleType:   "tokens",
   pattern: ( (?$added [{lemma:"medio"}] || [{myNUM:"myNUMBER"} && {mySTValue:"3"}] [{word:/cuartos|CUARTOS/}] [{lemma:"de"}] || [{word:/[C|c][U|u][A|a][R|r][T|t][O|o]/}] [{lemma:"de"}]) (?$granu [{myNER:"DGRANULARITY"}]+) ),
      action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$MedioDia"), Annotate($0, "timexValue", :case{($added[0].lemma == "medio") => HALF_DURATION_MAP[$granu[0].myNERnormalized], ($added[0].mySTValue == "3") => TQUARTER_DURATION_MAP[$granu[0].myNERnormalized], :else => QUARTER_DURATION_MAP[$granu[0].myNERnormalized]}), Annotate($0, DURATION_MAP[$granu[0].myNERnormalized], $granu[0].timexValue), Annotate($0, "Period", $granu[0].Period) ) , 
	  stage : 14  }
  
# eg: dos veces
{ ruleType:   "tokens",
  pattern: ( ([{myNUM:"myNUMBER"}]+) ([{lemma:"vez"}]) ),
  action: ( Annotate($0, "myRule", "Rule$numVeces"), Annotate($0, "myNER", "TIMES"), Annotate($0, "myNERnormalized", Concat($1[0].mySTValue,"X")) )  ,
  stage : 5  }
  
# eg: una vez
{ ruleType:   "tokens",
  pattern: ( ([{lemma:"uno"}]) ([{lemma:"vez"}]) ),
  action: ( Annotate($0, "myRule", "Rule$unaVez"), Annotate($0, "myNER", "TIMES"), Annotate($0, "myNERnormalized", "1X") )  ,
  stage : 5  }

  
   
{ ruleType: "composite",
priority: 2.0,
  pattern: ( [{lemma:/d?el/}]? (?: [{myNER:"WEEKDAY"}] /,/? [{lemma:"a"}]?)? [{lemma:"día"}]? ([{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})]+) (?: [{lemma:"de"}] | [{lemma:"del"}])?  ([{myNER:"MONTHS"}]+) (?: (?: [{lemma:"de"} | {lemma:"del"} | /,/])? [{lemma:"año"}]?)?  ([{myNER:"YEAR"}]+)? ) ,
  action: ( Annotate($0, "timexType","DATE"), Annotate($0, "myRule","Rule$DDdeMMdeYYYY"), Annotate($0, "timexValue", Concat(:case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}, "-", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}, "-", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"})), :case{ ($$1 != NIL || $$3 != NIL  ) => (Annotate($0, "myDateDay", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"}), Annotate($0, "myDateMonth", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}),Annotate($0, "myDateYear", :case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}));} ), 
  result: ( "DATE", $0[0].timexValue, "", "", "Rule$DDdeMMdeYYYY")  ,
  # result: ( "DATE", Concat(:case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}, "-", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}, "-", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"}), "", "", "Rule$DDdeMMdeYYYY")  ,
  stage : 25  } 
  
{ ruleType: "composite",
priority: 2.0,
  pattern: ( [{lemma:/d?el/}]? (?: [{myNER:"WEEKDAY"}] /,/? [{lemma:"a"}]?)? [{lemma:"día"}]? ([{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})]+)? (?: [{lemma:"de"}] | [{lemma:"el"}])?  ([{myNER:"MONTHS"}]+) (?: (?: [{lemma:"de"} | {lemma:"del"} | /,/])? [{lemma:"año"}]?)?  ([{myNER:"YEAR"}]+)) ,
  action: ( Annotate($0, "timexType","DATE"), Annotate($0, "myRule","Rule$DDdeMMdeYYYY"), Annotate($0, "timexValue", Concat(:case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}, "-", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}, "-", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"})), :case{ ($$1 != NIL || $$3 != NIL  ) => (Annotate($0, "myDateDay", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"}), Annotate($0, "myDateMonth", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}),Annotate($0, "myDateYear", :case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}));} ), 
  result: ( "DATE", $0[0].timexValue, "", "", "Rule$DDdeMMdeYYYY")  ,
  # result: ( "DATE", Concat(:case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}, "-", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}, "-", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"}), "", "", "Rule$DDdeMMdeYYYY")  ,
  stage : 25  } 
  
{ ruleType: "composite",
matchedExpressionGroup: 1,
priority: 3.0,
  pattern: ( (?$total (?: (?: [{lemma:"en"}]?  [{lemma:"el"}] [{lemma:"año"}]?) | (?: [{lemma:"en"} | {lemma:"año"}]))  (?$year [{myNER:"YEAR"}]+) (?$AC ([{word:/[A|a]\.?[C|c]\.?/}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:/[C|c]risto/}])))? (?:[!{pos:/NC.*/}])) ) ,
  action: ( Annotate($total, "myDateYear", :case{ ($$year != NIL) => Concat(:case{($$AC != NIL) => "BC", :else => ""}, $year[0].myNERnormalized), :else => "XXXX"}) ),
  stage : 200  }  

# cuidado con el entre
# Sucesion de dias

{ ruleType: "tokens",
  pattern: ( [{lemma:"el"}]?  [{lemma:"día"}] ([{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})]+) ) ,
  action: ( Annotate($0, "myRule", "Rule$eldia2"), Annotate($0, "timexType", "DATE"), Annotate($0, "myNER", "SPDAY"), Annotate($0, "myDateDay", Format("%02d", $1[0].myTValue)), Annotate($0, "timexValue", Concat("XXXX-XX-", Format("%02d", $1[0].myTValue)))),
  stage : 100  }
  
  
{ ruleType: "tokens",
  pattern: ( ((?$day0 [{myNER:"SPDAY"}]+) (?: /,/ | /y/ | /al/ | /hasta/))+ [{lemma:"el"}]?  [{lemma:"día"}]? (?$day [{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})]+) ) ,
  action: ( Annotate($day, "myRule", "Rule$eldia2y4"), Annotate($day, "timexType", "DATE"), Annotate($day, "myNER", "SPDAY"), Annotate($day, "myDateDay", Format("%02d", $day[0].myTValue)), Annotate($day, "timexValue", Concat("XXXX-XX-", Format("%02d", $day[0].myTValue))), Annotate($day0, "myRule", "Rule$eldia2y4"), Annotate($day0, "timexType", "DATE"), Annotate($day0, "myNER", "SPDAY")),
  stage : 101  }
  
  
  #TODO: deberia ser intervalo  
{ ruleType: "tokens",
  pattern: ( (?: [{lemma:"el"}]?  [{lemma:"día"}]? [({myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})) & !{timexType:"TIME"}]+ (?: /,/ | [{lemma:"y"} | {lemma:"o"} | {lemma:"a"} | {lemma:"al"} | {lemma:"hasta"}]))+  [{lemma:"el"}]? ([({myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})) & !{timexType:"DURATION"} & {timexType:"DATE"} & !{timexType:"TIME"}]) ) ,
  action: ( Annotate($0, "myRule", "Rule$el2yel3deoctubre"), Annotate($0, "myDateMonth", $1[0].myDateMonth), Annotate($0, "timexType", "DATE"), Annotate($0, "myDateYear", $1[0].myDateYear)),
  stage : 100  }
  
  #TODO: deberia ser intervalo  
{ ruleType: "tokens",
  pattern: ( (?$new [{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})]+) (?: /,/ | /y/ | /al/ | /hasta/ | /a/ | /o/)+  (?$totold [{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/} & {timexType:"DURATION"})]+ (?$old [{timexType:"DURATION"}]+)) ) ,
  action: ( Annotate($new, "myRule", "Rule$de2a3dur"), Annotate($new, "timexValue", Concat($old[0].Period, $new[0].mySTValue, :case{($old[0].Period == "PT") => TGRANULARITY_UNIT_MAP[$old[0].myNERnormalized], :else => DGRANULARITY_UNIT_MAP[$old[0].myNERnormalized]})), Annotate($new, "timexType", "DURATION"), Annotate($new, "Period", $old[0].Period), Annotate($totold, "myRule", "Rule$de2a3dur"), Annotate($totold, "timexValue", $totold[0].timexValue), Annotate($totold, "timexType", "DURATION") ),
  stage : 99  }  

{ ruleType: "composite",
 matchedExpressionGroup: 1,
  pattern: ( ([{lemma:/d?el/}]?  (?: [{myNER:"WEEKDAY"}] /,/? [{lemma:"a"}]?)? (?$dig [{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})]+)) (?: [{lemma:"y"} | {lemma:"o"} | {lemma:"a"} | {lemma:"al"} | {lemma:"hasta"}] | /,/)  [{lemma:/d?el/}]? ([{myRule:/Rule\$DDdeMMdeYYYY|Rule\$DDdeMMdeYYYYCom/}]) ) ,
  action: ( Annotate($1, "myRule", "Rule$DDdeMMdeYYYYCom"), Annotate($1, "timexType", "DATE"), Annotate($1, "myDateDay", $dig[0].myNERnormalized)),
  result: ( "DATE", Concat($dig[0].myDateYear, "-", $dig[0].myDateMonth, "-", $dig[0].myDateDay), "", "","Rule$DDdeMMdeYYYYCom")  ,
  stage : 100  }  


# Sucesion de meses
{ ruleType: "tokens",
  pattern: ( (?:  [{myNER:"MONTHS"}]+ (?: [{lemma:"y"}] | /,/))+  ([{myNER:"MONTHS"}]+) ) ,
  action: ( Annotate($0, "myRule", "Rule$octubreydiciembre"), Annotate($0, "myDateYear", $1[0].myDateYear)),
  stage : 100  }

{ ruleType: "composite",
 matchedExpressionGroup: 1,
 priority: 1.0,
  pattern: ( ([{myNER:"MONTHS"}]+) (?: [{lemma:"y"} | {lemma:"o"} | {lemma:"a"} | {lemma:"al"} | {lemma:"hasta"}] | /,/) ([{myRule:/Rule\$DDdeMMdeYYYY|Rule\$DDdeMMdeYYYYCom/}]) ) ,
  action: ( Annotate($1, "myRule", "Rule$DDdeMMdeYYYYCom"), Annotate($1, "timexType", "DATE"), Annotate($1, "myDateMonth", $1[0].myNERnormalized)),
  result: ( "DATE", Concat($1[0].myDateYear, "-", $1[0].myDateMonth), "", "", "Rule$DDdeMMdeYYYYCom")  ,
  stage : 100  } 


# Sucesion de duraciones
{ ruleType: "composite",
 priority: 1.0,
  pattern: ( [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]) (?: /,/) [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]) ) ,
#    pattern: ( [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]{2}) (?: /,/) [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]) ) ,
  action: ( :case{(DURATION_MAP[$1[0].myNERnormalized] != DURATION_MAP[$2[0].myNERnormalized]) => (Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$1añoy2meses"), Annotate($0, DURATION_MAP[$1[0].myNERnormalized], $1[0].timexValue) , Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue), Annotate($0, "Period", :case{($1[0].Period == "PT" || $2[0].Period == "PT") => "PT", :else => "P" })) ;}),
  stage : 100  }
  
# Sucesion de duraciones
{ ruleType: "composite",
 priority: 1.0,
  pattern: ( [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]) (?: [{lemma:"y"}]) [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]) ) ,
 #   pattern: ( [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]{2}) (?: [{lemma:"y"}]) [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]) ) ,
  action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$1añoy2meses"), Annotate($0, DURATION_MAP[$1[0].myNERnormalized], $1[0].timexValue) , Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue), Annotate($0, "Period", :case{($1[0].Period == "PT" || $2[0].Period == "PT") => "PT", :else => "P" }) ),
  stage : 100  }
  
  
#   { ruleType: "tokens",
#  priority: 1.0,
#   pattern: ( (?$num [{myNUM:"myNUMBER"}]+) (?: [{lemma:"y"} | {lemma:"o"}] | /,/) ([{timexType:"DURATION"}]* (?: ([{lemma:"y"} | {lemma:"o"}] | /,/))?)* (?$ref [{timexType:"DURATION"} & {myNER:"DGRANULARITY"}]) ) ,
#   action: ( Annotate($num, "timexType", "DURATION"), Annotate($num, "myRule", "Rule$1o2meses") , Annotate($num, DURATION_MAP[$ref[0].myNERnormalized], Concat($num[0].mySTValue, DGRANULARITY_UNIT_MAP[$ref[0].myNERnormalized])), Annotate($num, "timexValue", Concat($num[0].mySTValue, DGRANULARITY_UNIT_MAP[$ref[0].myNERnormalized]) )),
#  stage : 100  }
  
  

  
{ ruleType: "composite",
 priority: 1.0,
  pattern: ( ([{myRule:"Rule$1añoy2meses"}]+) ) ,
  action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$1añoy2meses"), Annotate($0, "timexValue", Concat("", :case {($0[1].myDurationDecade == NIL ) => "" , :else => $0[1].myDurationDecade}, :case {($0[1].myDurationYear == NIL ) => "" , :else => $0[1].myDurationYear}, :case {($0[1].myDurationMonth == NIL ) => "" , :else => $0[1].myDurationMonth}, :case {($0[1].myDurationWeek == NIL ) => "" , :else => $0[1].myDurationWeek}, :case {($0[1].myDurationWeekend == NIL ) => "" , :else => $0[1].myDurationWeekend}, :case {($0[1].myDurationDay == NIL ) => "" , :else => $0[1].myDurationDay}, :case {($0[1].myDurationHour == NIL ) => "" , :else => $0[1].myDurationHour}, :case {($0[1].myDurationMinute == NIL ) => "" , :else => $0[1].myDurationMinute}, :case {($0[1].myDurationSecond == NIL ) => "" , :else => $0[1].myDurationSecond})) ),
  #result: ( "DURATION", Concat($0[0].Period, :case {($0[1].myDurationDecade == NIL ) => "" , :else => $0[1].myDurationDecade}, :case {($0[1].myDurationYear == NIL ) => "" , :else => $0[1].myDurationYear}, :case {($0[1].myDurationMonth == NIL ) => "" , :else => $0[1].myDurationMonth}, :case {($0[1].myDurationWeek == NIL ) => "" , :else => $0[1].myDurationWeek}, :case {($0[1].myDurationWeekend == NIL ) => "" , :else => $0[1].myDurationWeekend}, :case {($0[1].myDurationDay == NIL ) => "" , :else => $0[1].myDurationDay}, :case {($0[1].myDurationHour == NIL ) => "" , :else => $0[1].myDurationHour}, :case {($0[1].myDurationMinute == NIL ) => "" , :else => $0[1].myDurationMinute}, :case {($0[1].myDurationSecond == NIL ) => "" , :else => $0[1].myDurationSecond}), "", "", "Rule$1añoy2meses")  ,
  stage : 199  }
  

####### Anchor
  
  # TODO: Mañana hará dos años
#{ ruleType: "composite",
# priority: 1.0,
#  pattern: ( [{lemma:/hacer/}] ([{timexType:"DURATION"} & !{timexValue:/.*X.*/}]+) ) ,
#  annotate: ( Annotate($0, "timexType", "DATE"), Annotate($0, "myRule", "Rule$haceDUR"), Annotate($0, "timexValue", Concat("anchor(TODAY,", "-,", $1[0].timexValue,")")) ),
#  result: ( "DATE", Concat("anchor(TODAY,", "-,", $1[0].timexValue,")"), "", "", "Rule$haceDUR")  ,
#  stage : 200  }  

  # TODO: Mañana hará dos años
{ ruleType: "composite",
 priority: 1.0,
  pattern: ( [{lemma:/hacer/} | {lemma:/quedar/} | {lemma:/pasar/} | {lemma:/faltar/}] [{pos:"RG"}]? ([{timexType:"DURATION"}]+) ) ,
  annotate: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$haceDUR"), Annotate($0, "timexValue", $1[0].timexValue) ),
  result: ( "DURATION", $1[0].timexValue, "", "", "Rule$haceDUR")  ,
  stage : 200  }  
  
  
{ ruleType: "tokens",
  pattern: ( [{lemma:/hacer/} | {lemma:/quedar/} | {lemma:/pasar/} | {lemma:/faltar/}] [{pos:"RG"} | {pos:"D.*"} | {pos:"A.*"} | {word:"un"}]* [{lemma:"poco"}] ) ,
  annotate: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$haceDUR"), Annotate($0, "timexValue", "PXM") ),
  result: ( "DURATION", "PXM", "", "", "Rule$haceX")  ,
  stage : 200  } 
  
  #note
{ ruleType: "tokens",
  pattern: ( [{lemma:/hacer/} | {lemma:/quedar/} | {lemma:/pasar/} | {lemma:/faltar/}] [{pos:"RG"} | {pos:"D.*"} | {pos:"A.*"} | {word:"un"}]* [{lemma:"tiempo"}] ) ,
  annotate: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$haceDUR"), Annotate($0, "timexValue", "XM") ),
  result: ( "DURATION", "XM", "", "", "Rule$haceX")  ,
  stage : 200  } 

  #note  
{ ruleType: "tokens",
  pattern: ( [{lemma:/hacer/} | {lemma:/quedar/} | {lemma:/pasar/} | {lemma:/faltar/}] [{pos:"RG"} | {pos:"D.*"} | {pos:"A.*"} | {word:"un"}]* [{lemma:"momento"} | {lemma:"rato"}] ) ,
  annotate: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$haceDUR"), Annotate($0, "timexValue", "XMIN") ),
  result: ( "DURATION", "XMIN", "", "", "Rule$haceX")  ,
  stage : 200  } 
   

# NO USEFUL LEGAL DOMAIN
# { ruleType: "tokens", 
#matchWithResults: TRUE,
#  pattern: ( /(\d\d\d\d)[-|\/](\d\d\d\d)/ ) ,
#   annotate: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$yyyy-yyyy"), Annotate($0, "timexValue", Concat(Subtract({ type: "NUMBER", value: $$0.matchResults[0].word.group(2)},{ type: "NUMBER", value: $$0.matchResults[0].word.group(1) }),"Y")) ),
#   result: ( "DURATION", Concat(Subtract({ type: "NUMBER", value: $$0.matchResults[0].word.group(2)},{ type: "NUMBER", value: $$0.matchResults[0].word.group(1) }),"Y"), "", "", "Rule$yyyy-yyyy")  ,
#   stage : 200  } 

# NO USEFUL LEGAL DOMAIN
# { ruleType: "tokens", 
#matchWithResults: TRUE,
#   pattern: ( /\d?\d?(\d\d)[-|\/](\d\d)/ ) ,
#   annotate: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$yyyy-yyyy"), Annotate($0, "timexValue", "1Y") ),
#   result: ( "DURATION", Concat(Subtract({ type: "NUMBER", value: $$0.matchResults[0].word.group(2)},{ type: "NUMBER", value: $$0.matchResults[0].word.group(1) }),"Y"), "", "", "Rule$yyyy-yyyy")  ,
#   stage : 200  }     

  
#TODO: maybe better "last date" instead of TODAY as ref
# quitado para tempeval2
# { ruleType: "composite",
#  priority: 1.0,
#   pattern: ( ([{timexType:"DURATION"} & !{timexValue:/.*X.*/}]+) [{lemma:/antes/}] ) ,
#   annotate: ( Annotate($0, "timexType", "DATE"), Annotate($0, "myRule", "Rule$haceDUR"), Annotate($0, "timexValue", Concat("anchor(TODAY,", "-,", $1[0].timexValue,")")) ),
#   result: ( "DATE", Concat("anchor(TODAY,", "-,", $1[0].timexValue,")"), "", "", "Rule$haceDUR")  ,
#   stage : 200  }  
  
# { ruleType: "composite",
#  priority: 1.0,
#   pattern: ( [{lemma:/dentro/}] [{lemma:/de/}] ([{timexType:"DURATION"} & !{timexValue:/.*X.*/}]+) ) ,
#   annotate: ( Annotate($0, "timexType", "DATE"), Annotate($0, "myRule", "Rule$enDUR"), Annotate($0, "timexValue", Concat("anchor(TODAY,", "+,", $1[0].timexValue,")")) ),
#   result: ( "DATE", Concat("anchor(TODAY,", "+,", $1[0].timexValue,")"), "", "", "Rule$enDUR")  ,
#   stage : 200  }  
  
#{ ruleType: "composite",
# priority: 1.0,
#  pattern: ( [{lemma:/en/}] ([{timexType:"DURATION"} & !{timexValue:/.*X.*/}]+) ) ,
#  annotate: ( Annotate($0, "timexType", "DATE"), Annotate($0, "myRule", "Rule$enDUR"), Annotate($0, "timexValue", Concat("anchor(TODAY,", "+,", $1[0].timexValue,")")) ),
#  result: ( "DATE", Concat("anchor(TODAY,", "+,", $1[0].timexValue,")"), "", "", "Rule$enDUR")  ,
#  stage : 200  }   



# prox/last dates
  
  
    { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myRule:"Rule$DDdeMMdeYYYY"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$anteriorDate"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("Danchor(-,", $gran[0].timexValue,")")) ) , 
  result: ( "DATE", $gran[0].timexValue, "", "", "Rule$anteriorDate" ) ,
  stage : 499  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myRule:"Rule$DDdeMMdeYYYY"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$proximoDate"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("Danchor(+,", $gran[0].timexValue,")")) ) , 
  result: ( "DATE", $gran[0].timexValue, "", "", "Rule$proximoDate" ) ,
  stage : 499  }
  
      { ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? (?$gran [{myRule:"Rule$DDdeMMdeYYYY"}]+) ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+)),
  action: ( Annotate($0, "myRule", "Rule$anteriorDate"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("Danchor(-,", $gran[0].timexValue,")")) ) , 
  result: ( "DATE", $gran[0].timexValue, "", "", "Rule$anteriorDate" ) ,
  stage : 499  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? (?$gran [{myRule:"Rule$DDdeMMdeYYYY"}]+) ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$Dateproximo"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("Danchor(+,", $gran[0].timexValue,")")) ) , 
  result: ( "DATE", $gran[0].timexValue, "", "", "Rule$Dateproximo" ) ,
  stage : 499  }  
  
  
# prox/last seasons
  
  
    { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myNER:"SEASON"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$anteriorSeason"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("Sanchor(-,", $gran[0].timexValue,")")) ) , 
  result: ( "DATE", $gran[0].timexValue, "", "", "Rule$anteriorSeason" ) ,
  stage : 499  }
  
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) (?$gran [{myNER:"SEASON"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$proximoSeason"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("Sanchor(+,", $gran[0].timexValue,")")) ) , 
  result: ( "DATE", $gran[0].timexValue, "", "", "Rule$proximoSeason" ) ,
  stage : 499  }
  
      { ruleType:   "tokens",
  pattern: (  [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? (?$gran [{myNER:"SEASON"}]+) ([{myNER:"PAS_REF_Adj"} & {pos:/A.*S.*/}]+)),
  action: ( Annotate($0, "myRule", "Rule$anteriorSeason"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("Sanchor(-,", $gran[0].timexValue,")")) ) , 
  result: ( "DATE", $gran[0].timexValue, "", "", "Rule$anteriorSeason" ) ,
  stage : 499  }
  
    
  { ruleType:   "tokens",
  pattern: ( [{pos:/D[A|D]0.S0/} | {pos:/SPCMS/}]? (?$gran [{myNER:"SEASON"}]+) ([{myNER:"FUT_REF_Adj"} & {pos:/A.*S.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$Seasonproximo"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("Sanchor(+,", $gran[0].timexValue,")")) ) , 
  result: ( "DATE", $gran[0].timexValue, "", "", "Rule$Seasonproximo" ) ,
  stage : 499  }  
  

  
  
  
####### ISOLATED
    # PartDay isolated
{ ruleType:   "composite",
  pattern: ( [{myRule:"Rule$PARTDAY"}]+  ),
  result: ( "TIME", Concat("anchor(TODAY,x,D)T",$0[0].timexValue), "", "", "Rule$PARTDAY" ) ,
  stage : 500  } 
  
  # Weekday isolated
{ ruleType:   "composite",
  pattern: ( [{myRule:"Rule$WEEKL"}]  ),
  result: ( "DATE", Concat($0[0].timexValue,""), "", "", "Rule$WEEKL" ) ,
  stage : 500  } 
  
# Month isolated
{ ruleType:   "composite",
  pattern: ( [{myNER:"MONTHS"} && !{myRule:/Rule\$DDdeMMdeYYYY(Com)?/} && !{myRule:"Rule$anteriorMonthS"} &&  !{myRule:"Rule$proximoMonthS"}]+  ),
  result: ( "DATE", Concat($0[0].timexValue,""), "", "", "Rule$MONTHS" ) ,
  stage : 500  } 
  
{ ruleType:   "tokens",
  pattern: ( [{myRule:"Rule$anteriorMonthS"} |  {myRule:"Rule$proximoMonthS"}]+  ),
  result: ( "DATE", $0[0].timexValue, "", "", $0[0].myRule ) ,
  stage : 500  } 
  
  
  # Weekend isolated
{ ruleType:   "composite",
  pattern: ( [{myTType:"finsemana"}]+  ),
  result: ( "DATE", Concat($0[0].timexValue,""), "", "", "Rule$finsemana" ) ,
  stage : 500  } 
  
    # anchored isolated
{ ruleType:   "composite",
  # pattern: ( [{timexValue:/anchor.*/}]+  ),  
  pattern: ( [{timexValue:/anchor.*/} && !{timexType:"TIME"}]+  ),
  result: ( "DATE", Concat($0[0].timexValue,""), "", "", $0[0].myRule ) ,
  stage : 500  } 
  
   # duration
 { ruleType:   "composite",
   pattern: ( [{myRule:"Rule$INDEFDGranularity"}]+  ),
   result: ( "DURATION", $0[0].timexValue, "", "", "Rule$INDEFDGranularity" ) ,
   stage : 600  } 
   
  { ruleType:   "composite",
   pattern: ( [{timexType:"DURATION"}]+  ),
   result: ( "DURATION", Concat("", $0[0].timexValue), "", "", $0[0].myRule ) ,
   stage : 500  } 
  
     # time
{ ruleType:   "tokens",
  pattern: ( /[L|l][A|a][S|s]?/? ([{timexType:"TIME"}]+) [{word:/[H|h][O|o][R|r][A|a][S|s]?/}]? [{word:/[L|l][O|o][C|c][A|a][L|l]/}]? ),
  action: (Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", $1[0].timexValue)),
  #result: ( "TIME", $1[0].timexValue, "", "", $1[0].myRule ) ,
    result: ( "TIME", Concat("anchor(TODAY,x,D)",$1[0].timexValue), "", "", $1[0].myRule ) ,
  stage : 500  } 
  
      # set
{ ruleType:   "composite",
  pattern: ( [{timexType:"SET"}]+  ),
  result: ( "SET", Concat($0[1].timexValue,""), :case{($0[0].timexFreq != NIL) => Concat($0[0].timexFreq, ""), :else => ""} , :case{($0[0].timexQuant != NIL) => Concat($0[0].timexQuant, ""), :else => ""}, $0[0].myRule ) ,
  stage : 499  } 
  
        # dateRefs
{ ruleType:   "composite",
  pattern: ( [{timexType:"DATE"} && {timexValue:/.+_REF/}]+  ),
  result: ( "DATE", Concat($0[0].timexValue,""), "", "", $0[0].myRule ) ,
  stage : 500  } 
  
        # date en el año
{ ruleType:   "composite",
  pattern: ( ([{timexType:"DATE"} && {myRule:"Rule$EnElAñoMyNumber"}]+)  ),
  result: ( "DATE", Concat($1[0].timexValue,""), "", "", "Rule$EnElAñoMyNumber" ) ,
  stage : 200  }   

  
        # date en el año
{ ruleType:   "composite",
  pattern: ( ([{timexType:"DATE"} && {myRule:"Rule$EnElAñoYYYY"}]+)  ),
  result: ( "DATE", Concat($1[0].timexValue,""), "", "", "Rule$EnElAñoYYYY" ) ,
  stage : 200  }   
  
  
  
        # date el dia
{ ruleType:   "composite",
  pattern: ( ([{timexType:"DATE"} && {myRule:"Rule$eldia2y4"}]+)  ),
  result: ( "DATE", Concat($1[0].timexValue,""), "", "", "Rule$eldia2y4" ) ,
  stage : 200  }  
  
  
          # agregada post para evitar los días 15 y 16 de marzo del 2001
{ ruleType:   "composite",
  pattern: ( ([{timexType:"DATE"} && {myRule:"Rule$eldia2y4"}]+ (?$fecha [{myRule:/Rule\$DDdeMMdeYYYY(Com)?/}]+))  ),
  result: ( "DATE", $fecha[0].timexValue, "", "", "Rule$DDdeMMdeYYYYCom" ) ,
  stage : 201  }  
  
 
  
          # date el dia (first ones are in case of adjectives...)
{ ruleType:   "composite",
  pattern: ( [{timexType:"DATE"}]* ([{timexType:"DATE"} && {myRule:"Rule$eldia2"}]+)  ),
  result: ( "DATE", Concat($1[0].timexValue,""), "", "", "Rule$eldia2" ) ,
  stage : 200  }  
  

  
        # season
{ ruleType:   "composite",
  pattern: ( ([{timexType:"DATE"} && {myRule:"Rule$SEASON"}]+)  ),
  result: ( "DATE", Concat($1[0].timexValue,""), "", "", "Rule$SEASON" ) ,
  stage : 200  } 
  
  { ruleType:   "composite",
  pattern: ( ([{timexType:"DATE"} && {myRule:"Rule$interval"}]+)  ),
  result: ( "DATE", Concat($1[0].timexValue,""), "", "", "Rule$interval" ) ,
  stage : 200  } 
  
  { ruleType:   "composite",
  pattern: ( [{myNER:"MOD"}]+ ([{timexType:"DATE"}]+)  ),
  result: ( "DATE", Concat($1[0].timexValue,""), "", "", "Rule$modDate" ) ,
  stage : 2000  } 
  
    { ruleType:   "composite",
  pattern: ( [{myNER:"MOD"}]+ ([{timexType:"DURATION"}]+)  ),
  result: ( "DURATION", Concat($1[0].timexValue,""), "", "", "Rule$modDur" ) ,
  stage : 2000  } 
  
      { ruleType:   "composite",
  pattern: ( [{myNER:"MOD"}]+  /a/? ([{timexType:"TIME"}]+)  ),
  result: ( "TIME", Concat($1[0].timexValue,""), "", "", "Rule$modTIME" ) ,
  stage : 2000  } 
  
  
  # NOT USEFUL FOR THE LEGAL DOMAIN
  
  # adj proximo (evitar proximo a)
{ ruleType:   "tokens",
  pattern: ( ([{pos:/AQ.*/} && {lemma:/próximo/} && !{timexValue:/.*/}]+)  [!{pos:/SPS.*/}] ),
  action: ( Annotate($1, "myRule", "Rule$FutureRef"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "FUTURE_REF") )  ,
  stage : 699  } 
  
{ ruleType:   "tokens",
  pattern: ( ([{pos:/AQ.*/} && {lemma:/futuro/} && !{timexValue:/.*/}]+) ),
  action: ( Annotate($1, "myRule", "Rule$FutureRef"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "FUTURE_REF") )  ,
  stage : 699  } 

  # adj proximo
{ ruleType:   "tokens",
  pattern: ( [{myRule:"Rule$FutureRef"}] ),
  result: ( "DATE", "FUTURE_REF", "", "", "Rule$AdjProximo" ) ,
  stage : 700  }   


# he quitado "antiguo"
{ ruleType:   "tokens",
  pattern: ( [!{word:"una"}] ([{pos:/AQ.*/} && {lemma:/reciente|pasado/} && !{timexValue:/.*/}]+)   ),
  action: ( Annotate($1, "myRule", "Rule$PastRef"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "PAST_REF") )  ,
  stage : 699  } 
  
  # adj reciente
{ ruleType:   "tokens",
  pattern: ( [{myRule:"Rule$PastRef"}] ),
  result: ( "DATE", "PAST_REF", "", "", "Rule$AdjReciente" ) ,
  stage : 700  }   

  # adj actual
{ ruleType:   "tokens",
  pattern: ( ([{pos:/AQ.*/} && {lemma:/actual/} && !{timexValue:/.*/}]+)  ),
  result: ( "DATE", "PRESENT_REF", "", "", "Rule$AdjActual" ) ,
  stage : 700  }  
  
    # adj presente
 #{ ruleType:   "tokens",
  # pattern: ( ([{pos:/AQ.*/} && {lemma:/presente/} && !{timexValue:/.*/}]+) [{pos:/AQ.*/ | }] ),
  # result: ( "DATE", "PRESENT_REF", "", "", "Rule$AdjPresente" ) ,
  # stage : 699  }  
  
  
    # adv proximamente
{ ruleType:   "tokens",
  pattern: ( [{pos:/RG.*/} && {lemma:/próximamente/} && !{timexValue:/.*/}]+  ),
  result: ( "DATE", "FUTURE_REF", "", "", "Rule$AdjProximo" ) ,
  stage : 700  }   

  # adj recientemente (quitamos previamente)
{ ruleType:   "tokens",
  pattern: ( [{pos:/RG.*/} && {lemma:/recientemente|antiguamente|antaño|[ú|u]ltimamente/} && !{timexValue:/.*/}]+  ),
  result: ( "DATE", "PAST_REF", "", "", "Rule$AdjReciente" ) ,
  stage : 700  }

{ ruleType:   "tokens",
  pattern: ( ([{pos:/RG.*/} && {lemma:/recién/} && !{timexValue:/.*/}]+) [!{lemma:nacer}]),
  Annotate: ( $1, "myRule", "Rule$AdjReciente" ) ,
  stage : 699  }  

{ ruleType:   "tokens",
  pattern: ( [{myRule:"Rule$AdjReciente"}]+),
  result: ( "DATE", "PAST_REF", "", "", "Rule$AdjReciente" ) ,
  stage : 700  }     

  # adj actualmente
{ ruleType:   "tokens",
  pattern: ( [{pos:/RG.*/} && {lemma:/actualmente/} && !{timexValue:/.*/}]+  ),
  result: ( "DATE", "PRESENT_REF", "", "", "Rule$AdjActual" ) ,
  stage : 700  }  

  
# eg: References to the present
{ ruleType:   "tokens",
  pattern: ([{lemma:"en"}] (?$total ( [{word:/[E|e][L|l]/}] [{lemma:"presente"} && !{pos:/A.*/}]) | ([{lemma:"el"}] [{lemma:"actualidad"}]))),
  action: ( Annotate($total, "myRule", "Rule$EnPresentRef"), Annotate($total, "timexType", "DATE"), Annotate($total, "timexValue", "PRESENT_REF") )  ,
  stage : 700  }
  
{ ruleType:   "tokens",
  pattern: ([{myRule:"Rule$EnPresentRef"}]+),
  result: ( "DATE", "PRESENT_REF", "", "", "Rule$EnPresentRef" ) ,
  stage : 700  }
  
  { ruleType:   "tokens",
  pattern: (([{lemma:"ahora"}] [{lemma:"mismo"}]) | ([{lemma:"hoy"}] [{lemma:"en"}] [{lemma:"día"}]) | ([{lemma:"a"}] [{lemma:"día"}] [{lemma:"de"}] [{lemma:"hoy"}])),
  action: ( Annotate($0, "myRule", "Rule$PresentRef"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "PRESENT_REF") )  ,
  result: ( "DATE", "PRESENT_REF", "", "", "Rule$PresentRef" ) ,
  stage : 700  }
  
{ ruleType:   "tokens",
  pattern: (([{lemma:"ahora"}]) [!{lemma:"bien"}]),
  action: ( Annotate($1, "myRule", "Rule$PresentRefAHORA"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "PRESENT_REF") )  ,
  stage : 700  }
  
  { ruleType:   "tokens",
  pattern: ([{myRule:"Rule$PresentRefAHORA"}]),
  result: ( "DATE", "PRESENT_REF", "", "", "Rule$PresentRefAHORA" ) ,
  stage : 701  }
  
    { ruleType:   "tokens",
  pattern: ((?$total (?$ref2 [{timexValue:"anchor(TODAY,+,0D)"} | {timexValue:"anchor(TODAY,+,1D)"} | {timexValue:"anchor(TODAY,-,1D)"}]+) /,/? (?$ref [{timexType:"DATE"}]+))),# (?:[{pos:"FP"} | {pos:"FC"} | {word:";"}] [!{timexType:"DATE"}])),
  action: ( Annotate($total, "myRule", "Rule$hoy,date"), Annotate($total, "timexType", "DATE"), Annotate($total, "timexValue", $ref2[0].timexValue) )  ,
  stage : 1000  }
  
      { ruleType:   "tokens",
  pattern: ([{myRule:"Rule$hoy,date"}]+),
  result: ( "DATE", $0[0].timexValue, "", "", "Rule$hoy,date" ) ,
  stage : 1001  }
  
  { ruleType:   "tokens",
  pattern: ([{lemma:"el"} | {lemma:"este"} | {lemma:"ese"}]? [{myNER:"FUT_REF_Adj"} | {myNER:"PAST_REF_Adj"} | {pos:/A.*/} | {pos:/D.*/}]? ([{timexType:"DURATION"}]+) [{myNER:"FUT_REF_Adj"} | {myNER:"PAST_REF_Adj"} | {pos:/A.*/}]?),
  result: ( "DURATION", $1[0].timexValue, "", "", "Rule$ProxDuration" ) ,
  stage : 1001  }

  
  
  
  

{ ruleType:   "tokens",
  pattern: ( [{lemma:/D.*S.*/}]? (?$season [{myNER:"SEASON"}]) [{lemma:"de"}]? [{lemma:"el"}]? [{lemma:"año"}]? (?$year [{myNER:"YEAR"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$SEASON"), Annotate($0, "myNER", "SEASON"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat($year[0].timexValue, $season[0].myNERnormalized))),
  stage : 5  }
  
  
  # eg: intervalos (tb podrian ser otras cosas, no solo años)
{ ruleType:   "tokens",
  pattern: ( ([{lemma:"a"}] [{lemma:"partir"}])? ([{lemma:"entre"} | {lemma:"desde"} | {lemma:"de"}]) [{lemma:"el"}]? [{lemma:"año"}]? (?$year1 [{myNER:"YEAR"}]+) [{lemma:"y"}]? ([{lemma:"y"} | {lemma:"a"} | {lemma:"al"} | {lemma:"hasta"}] ) [{lemma:"el"}]? [{lemma:"año"}]? (?$year2 [{myNER:"YEAR"}]+) [!{pos:/(NC|AQ).*/} & !{ner:"MONEY"}] ),
  action: ( Annotate($year1, "myRule", "Rule$interval"), Annotate($year1, "myNER", "INTERVAL"), Annotate($year1, "timexType", "DATE"), Annotate($year1, "timexValue", $year1[0].timexValue), Annotate($year2, "myRule", "Rule$interval"), Annotate($year2, "myNER", "INTERVAL"), Annotate($year2, "timexType", "DATE"), Annotate($year2, "timexValue", $year2[0].timexValue)),
  stage : 5  }
  
   # eg: intervalos (tb podrian ser otras cosas, no solo años)
{ ruleType:   "tokens",
  pattern: ( (([{lemma:"a"}] [{lemma:"partir"}] [{lemma:"de"}]) |[{lemma:"desde"}]) [{lemma:"el"}]? [{lemma:"año"}]? (?$year1 [{myNER:"YEAR"}]+) (([!{pos:/(N|AQ).*/} & !{ner:"MONEY"}])) ) ,
  action: ( Annotate($year1, "myRule", "Rule$interval"), Annotate($year1, "myNER", "INTERVAL"), Annotate($year1, "timexType", "DATE"), Annotate($year1, "timexValue", $year1[0].timexValue)),
  stage : 5  }
  
{ ruleType:   "tokens",
  pattern: ( ([{lemma:"y"} | {lemma:"a"} | {lemma:"hasta"}] ) [{lemma:"el"}]? [{lemma:"año"}]? (?$year2 [{myNER:"YEAR"}]+) ([!{pos:/(N|AQ).*/} & !{ner:"MONEY"}]) ),
  action: (  Annotate($year2, "myRule", "Rule$interval"), Annotate($year2, "myNER", "INTERVAL"), Annotate($year2, "timexType", "DATE"), Annotate($year2, "timexValue", $year2[0].timexValue)),
  stage : 5  }
  
  { ruleType:   "tokens",
  pattern: (  (([{word:/[L|l][O|o][S|s]/} | {word:/[A|a][Q|q][U|u][E|e][L|l][L|l][O|o][S|s]/}]  [{pos:/AQ.*/} | {pos:/NCMP.*/}]* [{word:/[A|a][Ñ|ñ][O|o][S|s]/}]) | ([{word:/[L|l][A|a]/}]? [{lemma:"década"}] [{lemma:"de"}] [{word:/[L|l][O|o][S|s]/}]?)) (?$dec [{myNUM:"myNUMBER"}]+) ),
  action: ( Annotate($0, "myNER", "los60"), Annotate($0, "myRule", "Rule$los60"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", :case{($dec[0].myTValue > 2000) => Format("%d", Divide($dec[0].myTValue, 10)), :else => Concat("19",Format("%d", Divide($dec[0].myTValue, 10)))}) ), 
  result: ( "DATE",:case{($dec[0].myTValue > 2000) => Format("%d", Divide($dec[0].myTValue, 10)), :else => Concat("19",Format("%d", Divide($dec[0].myTValue, 10)))}, "", "", "Rule$los60" ), 
  stage : 5  }



############ FILTER RULES

#{ ruleType: "filter",
#  pattern: ([{word:"última"}] [{word:"hora"}]),
#  stage : 5000  }

## tempeval2 train
{ ruleType:   "tokens",
  pattern: ( [{word:/[E|e]stos/}] [{word:"días"}]),
  result: ( "DATE","PRESENT_REF", "", "", "Rule$estosdias" ),
  stage : 5  }
  
{ ruleType:   "tokens",
  pattern: ( [{pos:/D.*S.*/} | {pos:/A.*S.*/} ]+ [{lemma:"rato"} | {lemma:"ratito"} | {lemma:"ratitín"} | {lemma:"ratete"} | {lemma:"ratejo"}] [{pos:/A.*S.*/} ]*),
  result: ( "DURATION","XMIN", "", "", "Rule$unrato" ),
  stage : 5  }  

{ ruleType:   "tokens",
  pattern: ( [{lemma:"el"}] [{pos:/A.*S.*/} ]* [{lemma:"momento"}] [{pos:/A.*S.*/} ]*),
  result: ( "DATE","PRESENT_REF", "", "", "Rule$elmomento" ),
  stage : 5  }  

  
#{ ruleType:   "tokens",
#  pattern: ( [{pos:/D.*S.*/} | {pos:/A.*S.*/} ]+ [{lemma:"momento"}] [{pos:/A.*S.*/} ]*),
#  result: ( "DURATION","XH", "", "", "Rule$unmomento" ),
#  stage : 5  }
    
{ ruleType:   "tokens",
  pattern: ( [{pos:/D.*S.*/} | {pos:/A.*S.*/} ]+ [{lemma:"momentito"} | {lemma:"momentín"}] [{pos:/A.*S.*/} ]*),
  result: ( "DURATION","XMIN", "", "", "Rule$unmomento" ),
  stage : 5  }
  

  


## MODS
{ ruleType:   "tokens",
  pattern: ( [{lemma:"a"} | {lemma:"al"} | {lemma:/del?/} | {lemma:"el"}]? (?$total (([{lemma:"casi"} | {lemma:"alrededor"} | {lemma:"apenas"} | {lemma:"aproximadamente"}] [{lemma:"de"}]?)? [{pos:/D.*/}]* ([{lemma:/[a|e]l/}]? ([{lemma:/final(es)?/} | {lemma:/fin/}]) [{lemma:/del?/}]) |  ([{lemma:/[a|e]l/}]? [{lemma:/principio(s)?/} | {lemma:/comienzo(s)?/} | {lemma:/comenzar/} | {lemma:/inicio(s)?/} | {lemma:/iniciar/}] [{lemma:/del?/}]) |  ([{lemma:"el"}]? [{lemma:/mediadio(s)?/} | {lemma:/mitad/}] [{lemma:/del?/}]) |  ( [{lemma:/m[á|a]s/} | {lemma:/menos/}] [{lemma:/del?/}]) |  ( [{lemma:/al?/}] [{lemma:/menos/}]) |  ( [{lemma:"todo"}])) [{pos:/D.*/}]*) ),
action: (Annotate($total, "myNER", "MOD"), Annotate($total, "myRule", "Rule$mod")),
  stage : 1  }
  
  { ruleType:   "tokens",
  pattern: ( (?$total [{word:/[L|l][O|o]/}] [{lemma:"que"}] [{lemma:"quedar"} | {lemma:"restar"}]) [{lemma:/del?/}] (?$gran [{myNER:/DGRANULARITY/}]+) ),
action: (Annotate($total, "myNER", "QUEDAR"), Annotate($total, "myRule", "Rule$loquequeda"), Annotate($total, "timexValue", Concat("Ranchor(+,",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")), Annotate($gran, "timexType", "DATE"), Annotate($gran, "timexValue", Concat("anchor(TODAY,x,", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")), Annotate($gran, "myRule", "Rule$loquequedaGRAN")),
  stage : 1000  }
  
  { ruleType:   "tokens",
  pattern: ( (?$total [{word:/[L|l][O|o]/}] [{lemma:"que"}] [{lemma:"ir"} | {lemma:"lleva"}]) [{lemma:/del?/}] (?$gran [{myNER:/DGRANULARITY/}]+) ),
action: (Annotate($total, "myNER", "QUEDAR"), Annotate($total, "myRule", "Rule$loquequeda"), Annotate($total, "timexValue", Concat("Ranchor(-,",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")), Annotate($gran, "timexType", "DATE"), Annotate($gran, "timexValue", Concat("anchor(TODAY,x,", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")), Annotate($gran, "myRule", "Rule$loquequedaGRAN")),
  stage : 1000  }
  
  { ruleType:   "tokens",
  pattern: ( (?$total [{word:/[L|l][O|o]/}] [{lemma:"resto"}]) [{lemma:/del?/}] (?$gran [{myNER:/DGRANULARITY/}]+) ),
action: (Annotate($total, "myNER", "QUEDAR"), Annotate($total, "myRule", "Rule$loquequeda"), Annotate($total, "timexValue", Concat("Ranchor(-,",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")), Annotate($gran, "timexType", "DATE"), Annotate($gran, "timexValue", Concat("anchor(TODAY,x,", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")), Annotate($gran, "myRule", "Rule$loquequedaGRAN")),
  stage : 1000  }
  
  { ruleType:   "tokens",
  pattern: ( [{myRule:"Rule$loquequeda"}]+ ),
result: ("DURATION", $0[0].timexValue, "", "","Rule$loquequeda"),
  stage : 1001  }
  
  
  { ruleType:   "composite",
  pattern: ( (?$timepart [{timexType:"TIME"}]+) [{lemma:/,/}]? [{lemma:/del?/}]? [{lemma:/el/}]? [{lemma:/día?/}]?  (?$datepart [{timexType:"DATE"} && {timexValue:/../}]+) /[A|a][L|l]/? ([{timexType:"DATE"}]+)?),
result: ("TIME", Concat("XXXX-XX-",$datepart[0].timexValue), "", "","Rule$TIMEdelDATE"),
  stage : 1002  }
  
  { ruleType:   "composite",
  pattern: ( (?$timepart [{timexType:"TIME"}]+) [{lemma:/,/}]? [{lemma:/del?/}]? [{lemma:/el/}]? [{lemma:/día?/}]?  (?$datepart [{timexType:"DATE"} && {timexValue:/..-../}]+) /[A|a][L|l]/? ([{timexType:"DATE"}]+)?),
result: ("TIME", Concat("XXXX-",$datepart[0].timexValue), "", "","Rule$TIMEdelDATE"),
  stage : 1002  }
  
  { ruleType:   "composite",
  pattern: ( (?$timepart [{timexType:"TIME"}]+) [{lemma:/,/}]? [{lemma:/del?/}]? [{lemma:/el/}]? [{lemma:/día?/}]?  (?$datepart [{timexType:"DATE"} && ({timexValue:/....-..-..*/} || {timexValue:/.*anchor.*/} )]+) /[A|a][L|l]/? ([{timexType:"DATE"}]+)?),
result: ("TIME", Concat($datepart[0].timexValue, "T", $timepart[0].timexValue), "", "","Rule$TIMEdelfullDATE"),
  stage : 1002  }

	{ ruleType:   "composite",
  pattern: ( (?$datepart [{timexType:"DATE"}]+) [{lemma:/,/}]? [{lemma:/a/}]? /[L|l][A|a][S|s]/? (?$timepart [{timexType:"TIME"}]+)),
result: ("TIME", Concat($datepart[0].timexValue, "T", $timepart[0].timexValue), "", "","Rule$DATEalasTIME"),
  stage : 1002  }						



  

  
  { ruleType:   "tokens",
  pattern: ( [{myRule:"Rule$loquequedaGRAN"}]+ ),
result: ("DATE", $0[0].timexValue, "", "","Rule$loquequedaGRAN"),
  stage : 1001  }
  
  
    { ruleType:   "tokens",
  pattern: ( [{word:/[N|n]avidad/}] ),
result: ("DATE", "XXXX-12-25", "", "","Rule$Navidad"),
  stage : 1001  }
  
    { ruleType:   "tokens",
  pattern: ( [{word:/[N|n]ochebuena/}] ),
result: ("DATE", "XXXX-12-24", "", "","Rule$Navidad"),
  stage : 1001  }
  
    { ruleType:   "tokens",
  pattern: ( ([{word:/[N|n]ochevieja/}] | ([{word:/[F|f]in/}] [{word:/de/}] [{word:/[A|a]ño/}])) ),
result: ("DATE", "XXXX-12-31", "", "","Rule$FindeAño"),
  stage : 1001  }
  
    { ruleType:   "tokens",
  pattern: ( [{word:/Año/}] [{word:/Nuevo/}] ),
result: ("DATE", "XXXX-01-01", "", "","Rule$AñoNuevo"),
  stage : 1001  }
  
      { ruleType:   "tokens",
  pattern: ( [{lemma:/d[í|i]a/}] [{word:/de/}] [{word:/[R|r]eyes/}] ),
result: ("DATE", "XXXX-01-06", "", "","Rule$DiaReyes"),
  stage : 1001  }
  
  { ruleType:   "tokens",
  pattern: ( [{lemma:/d[í|i]a/}] [{word:/de/}] [{word:/la/}] [{word:/[C|c]onstituci[ó|o]n/}] ),
result: ("DATE", "XXXX-12-06", "", "","Rule$DiaConstitución"),
  stage : 1001  }
  
  { ruleType:   "tokens",
  pattern: ( [{lemma:/d[í|i]a/}] [{word:/de/}] [{word:/[T|t]odos/}] [{word:/los/}] [{word:/[S|a]antos/}] ),
result: ("DATE", "XXXX-11-01", "", "","Rule$DiaConstitución"),
  stage : 1001  }
  
  { ruleType:   "tokens",
  pattern: ( [{word:/[H|h]alloween/}] ),
result: ("DATE", "XXXX-10-31", "", "","Rule$Halloween"),
  stage : 1001  }
  
    { ruleType:   "tokens",
  pattern: ( [{lemma:/[V|v]iernes/} | {lemma:/[J|j]ueves/}] [{word:/[S|a]anto/}] ),
result: ("DATE", "XXXX-04-XX", "", "","Rule$JVSanto"),
  stage : 1001  }
  
  { ruleType:   "tokens",
  pattern: ( [{lemma:/hacer/}] [{pos:"RG"} | {pos:"D.*"} | {pos:"A.*"}]* [{lemma:/tiempo/}] ),
result: ("DURATION", "PXM", "", "","Rule$haceTiempo"),
  stage : 1001  }
  
  { ruleType:   "composite",
  pattern: ( ([{timexType:"DATE"} & {timexValue:/.....*/}]+) [{lemma:/del?/}] ([{timexType:"DATE"}]+) ),
result: ("DATE", $1[0].timexValue, "", "","Rule$DatedeDate"),
  stage : 1001  }
  
  
  
#
